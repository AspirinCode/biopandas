{
    "docs": [
        {
            "location": "/",
            "text": "Working with molecular structures in pandas DataFrames\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinks\n\n\n\n\nDocumentation: \nhttp://rasbt.github.io/biopandas/\n\n\nSource code repository: \nhttps://github.com/rasbt/biopandas\n\n\nPyPI: \nhttps://pypi.python.org/pypi/biopandas\n\n\n\n\n\n\n\nAbout\n\n\nIf you are a computational biologist, chances are that you cursed one too many times about protein structure files. Yes, I am talking about ye Goode Olde Protein Data Bank format, aka \"PDB files.\" Nothing against PDB, it's a neatly structured format (if deployed correctly); yet, it is a bit cumbersome to work with PDB files in \"modern\" programming languages -- I am pretty sure we all agree on this.\n\n\nAs machine learning and \"data science\" person, I fell in love with \npandas\n DataFrames for handling just about everything that can be loaded into memory.\n\nSo, why don't we take pandas to the structural biology world? Working with molecular structures of biological macromolecules (from PDB and MOL2 files) in pandas DataFrames is what BioPandas is all about!\n\n\n\n\n\nExamples\n\n\n\n\n# Initialize a new PandasPdb object\n# and fetch the PDB file from rcsb.org\n>>> from biopandas.pdb import PandasPdb\n>>> ppdb = PandasPdb().fetch_pdb('3eiy')\n>>> ppdb.df['ATOM'].head()\n\n\n\n\n\n\n\n\n\n\n# Load structures from your drive and compute the\n# Root Mean Square Deviation\n>>> from biopandas.pdb import PandasPdb\n>>> pl1 = PandasPdb().read_pdb('./docking_pose_1.pdb')\n>>> pl2 = PandasPdb().read_pdb('./docking_pose_2.pdb')\n>>> r = PandasPdb.rmsd(pl1.df['HETATM'], pl2.df['HETATM'])\n>>> print('RMSD: %.4f Angstrom' % r)\nRMSD: 2.6444 Angstrom\n\n\n\n\n\n\n# Producing quick summary plots\n>>> import matplotlib.pyplot as plt\n>>> ppdb.df['ATOM']['b_factor'].plot(kind='hist')\n>>> plt.title('Distribution of B-Factors')\n>>> plt.xlabel('B-factor')\n>>> plt.ylabel('count')\n>>> plt.show()\n\n\n\n\n\n\n\n\n>>> ppdb.df['ATOM']['b_factor'].plot(kind='line')\n>>> plt.title('B-Factors Along the Amino Acid Chain')\n>>> plt.xlabel('Residue Number')\n>>> plt.ylabel('B-factor in $A^2$')\n>>> plt.show()",
            "title": "Home"
        },
        {
            "location": "/#links",
            "text": "Documentation:  http://rasbt.github.io/biopandas/  Source code repository:  https://github.com/rasbt/biopandas  PyPI:  https://pypi.python.org/pypi/biopandas",
            "title": "Links"
        },
        {
            "location": "/#about",
            "text": "If you are a computational biologist, chances are that you cursed one too many times about protein structure files. Yes, I am talking about ye Goode Olde Protein Data Bank format, aka \"PDB files.\" Nothing against PDB, it's a neatly structured format (if deployed correctly); yet, it is a bit cumbersome to work with PDB files in \"modern\" programming languages -- I am pretty sure we all agree on this.  As machine learning and \"data science\" person, I fell in love with  pandas  DataFrames for handling just about everything that can be loaded into memory. \nSo, why don't we take pandas to the structural biology world? Working with molecular structures of biological macromolecules (from PDB and MOL2 files) in pandas DataFrames is what BioPandas is all about!",
            "title": "About"
        },
        {
            "location": "/#examples",
            "text": "# Initialize a new PandasPdb object\n# and fetch the PDB file from rcsb.org\n>>> from biopandas.pdb import PandasPdb\n>>> ppdb = PandasPdb().fetch_pdb('3eiy')\n>>> ppdb.df['ATOM'].head()     # Load structures from your drive and compute the\n# Root Mean Square Deviation\n>>> from biopandas.pdb import PandasPdb\n>>> pl1 = PandasPdb().read_pdb('./docking_pose_1.pdb')\n>>> pl2 = PandasPdb().read_pdb('./docking_pose_2.pdb')\n>>> r = PandasPdb.rmsd(pl1.df['HETATM'], pl2.df['HETATM'])\n>>> print('RMSD: %.4f Angstrom' % r)\nRMSD: 2.6444 Angstrom   # Producing quick summary plots\n>>> import matplotlib.pyplot as plt\n>>> ppdb.df['ATOM']['b_factor'].plot(kind='hist')\n>>> plt.title('Distribution of B-Factors')\n>>> plt.xlabel('B-factor')\n>>> plt.ylabel('count')\n>>> plt.show()    >>> ppdb.df['ATOM']['b_factor'].plot(kind='line')\n>>> plt.title('B-Factors Along the Amino Acid Chain')\n>>> plt.xlabel('Residue Number')\n>>> plt.ylabel('B-factor in $A^2$')\n>>> plt.show()",
            "title": "Examples"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/",
            "text": "Working with PDB Structures in DataFrames\n\n\nLoading PDB Files\n\n\nThere are 2 1/2 ways to load a PDB structure into a \nPandasPdb\n object.\n\n\n1\n\n\nPDB files can be directly fetched from The Protein Data Bank at \nhttp://www.rcsb.org\n via its unique 4-letter after initializing a new \nPandasPdb\n object and calling the \nfetch_pdb\n method:\n\n\nfrom biopandas.pdb import PandasPdb\n\n# Initialize a new PandasPdb object\n# and fetch the PDB file from rcsb.org\nppdb = PandasPdb().fetch_pdb('3eiy')\n\n\n\n\n2 a)\n\n\nAlternatively, we can load PDB files from local directories as regular PDB files using \nread_pdb\n:\n\n\nppdb.read_pdb('./data/3eiy.pdb')\n\n\n\n\n<biopandas.pdb.pandas_pdb.PandasPdb at 0x106795898>\n\n\n\n2 b)\n\n\nOr, we can load them from gzip archives like so (note that the file must end with a '.gz' suffix in order to be recognized as a gzip file):\n\n\nppdb.read_pdb('./data/3eiy.pdb.gz')\n\n\n\n\n<biopandas.pdb.pandas_pdb.PandasPdb at 0x106795898>\n\n\n\nAfter the file was succesfully loaded, we have access to the following attributes:\n\n\nprint('PDB Code: %s' % ppdb.code)\nprint('PDB Header Line: %s' % ppdb.header)\nprint('\\nRaw PDB file contents:\\n\\n%s\\n...' % ppdb.pdb_text[:1000])\n\n\n\n\nPDB Code: 3eiy\nPDB Header Line:     HYDROLASE                               17-SEP-08   3EIY\n\nRaw PDB file contents:\n\nHEADER    HYDROLASE                               17-SEP-08   3EIY              \nTITLE     CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHATASE FROM BURKHOLDERIA      \nTITLE    2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE                                \nCOMPND    MOL_ID: 1;                                                            \nCOMPND   2 MOLECULE: INORGANIC PYROPHOSPHATASE;                                 \nCOMPND   3 CHAIN: A;                                                            \nCOMPND   4 EC: 3.6.1.1;                                                         \nCOMPND   5 ENGINEERED: YES                                                      \nSOURCE    MOL_ID: 1;                                                            \nSOURCE   2 ORGANISM_SCIENTIFIC: BURKHOLDERIA PSEUDOMALLEI 1710B;                \nSOURCE   3 ORGANISM_TAXID: 320372;                                              \nSOURCE   4 GENE: PPA, BURPS1710B_1237;                                          \nSOURCE   5 EXPRESSION_SYSTEM\n...\n\n\n\nThe most interesting / useful attribute is the \nPandasPdb.df\n DataFrame dictionary though, which gives us access to the PDB files as pandas DataFrames. Let's print the first 3 lines from the \nATOM\n coordinate section to see how it looks like:\n\n\nppdb.df['ATOM'].head(3)\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \nrecord_name\n\n      \natom_number\n\n      \nblank_1\n\n      \natom_name\n\n      \n...\n\n      \nsegment_id\n\n      \nelement_symbol\n\n      \ncharge\n\n      \nline_idx\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \nATOM\n\n      \n1\n\n      \n\n      \nN\n\n      \n...\n\n      \n\n      \nN\n\n      \nNaN\n\n      \n609\n\n    \n\n    \n\n      \n1\n\n      \nATOM\n\n      \n2\n\n      \n\n      \nCA\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n610\n\n    \n\n    \n\n      \n2\n\n      \nATOM\n\n      \n3\n\n      \n\n      \nC\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n611\n\n    \n\n  \n\n\n\n\n3 rows \u00d7 21 columns\n\n\n\n\n\nBut more on that in the next section.\n\n\nLooking at PDBs in DataFrames\n\n\nPDB files are parsed according to the \nPDB file format description\n. More specifically, BioPandas reads the columns of the ATOM and HETATM sections as shown in the following excerpt from \nhttp://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM\n.\n\n\n\n\n\n\n\n\nCOLUMNS\n\n\nDATA TYPE\n\n\nCONTENTS\n\n\nbiopandas column name\n\n\n\n\n\n\n\n\n\n\n1 - 6\n\n\nRecord name\n\n\n\"ATOM\"\n\n\nrecord_name\n\n\n\n\n\n\n7 - 11\n\n\nInteger\n\n\nAtom serial number.\n\n\natom_number\n\n\n\n\n\n\n12\n\n\n\n\n\n\nblank_1\n\n\n\n\n\n\n13 - 16\n\n\nAtom\n\n\nAtom name.\n\n\natom_name\n\n\n\n\n\n\n17\n\n\nCharacter\n\n\nAlternate location indicator.\n\n\nalt_loc\n\n\n\n\n\n\n18 - 20\n\n\nResidue name\n\n\nResidue name.\n\n\nresidue_name\n\n\n\n\n\n\n21\n\n\n\n\n\n\nblank_2\n\n\n\n\n\n\n22\n\n\nCharacter\n\n\nChain identifier.\n\n\nchain_id\n\n\n\n\n\n\n23 - 26\n\n\nInteger\n\n\nResidue sequence number.\n\n\nresidue_number\n\n\n\n\n\n\n27\n\n\nAChar\n\n\nCode for insertion of residues.\n\n\ninsertion\n\n\n\n\n\n\n28 - 30\n\n\n\n\n\n\nblank_3\n\n\n\n\n\n\n31 - 38\n\n\nReal(8.3)\n\n\nOrthogonal coordinates for X in Angstroms.\n\n\nx_coord\n\n\n\n\n\n\n39 - 46\n\n\nReal(8.3)\n\n\nOrthogonal coordinates for Y in Angstroms.\n\n\ny_coord\n\n\n\n\n\n\n47 - 54\n\n\nReal(8.3)\n\n\nOrthogonal coordinates for Z in Angstroms.\n\n\nz_coord\n\n\n\n\n\n\n55 - 60\n\n\nReal(6.2)\n\n\nOccupancy.\n\n\noccupancy\n\n\n\n\n\n\n61 - 66\n\n\nReal(6.2)\n\n\nTemperature factor (Default = 0.0).\n\n\nbfactor\n\n\n\n\n\n\n67-72\n\n\n\n\n\n\nblank_4\n\n\n\n\n\n\n73 - 76\n\n\nLString(4)\n\n\nSegment identifier, left-justified.\n\n\nsegment_id\n\n\n\n\n\n\n77 - 78\n\n\nLString(2)\n\n\nElement symbol, right-justified.\n\n\nelement_symbol\n\n\n\n\n\n\n79 - 80\n\n\nLString(2)\n\n\nCharge on the atom.\n\n\ncharge\n\n\n\n\n\n\n\n\nBelow is an example of how this would look like in an actual PDB file:\n\n\nExample: \n         1         2         3         4         5         6         7         8\n12345678901234567890123456789012345678901234567890123456789012345678901234567890\nATOM    145  N   VAL A  25      32.433  16.336  57.540  1.00 11.92      A1   N\nATOM    146  CA  VAL A  25      31.132  16.439  58.160  1.00 11.85      A1   C\nATOM    147  C   VAL A  25      30.447  15.105  58.363  1.00 12.34      A1   C\nATOM    148  O   VAL A  25      29.520  15.059  59.174  1.00 15.65      A1   O\nATOM    149  CB AVAL A  25      30.385  17.437  57.230  0.28 13.88      A1   C\nATOM    150  CB BVAL A  25      30.166  17.399  57.373  0.72 15.41      A1   C\nATOM    151  CG1AVAL A  25      28.870  17.401  57.336  0.28 12.64      A1   C\nATOM    152  CG1BVAL A  25      30.805  18.788  57.449  0.72 15.11      A1   C\nATOM    153  CG2AVAL A  25      30.835  18.826  57.661  0.28 13.58      A1   C\nATOM    154  CG2BVAL A  25      29.909  16.996  55.922  0.72 13.25      A1   C\n\n\n\nAfter loading a PDB file from rcsb.org or our local drive, the \nPandasPdb.df\n attribute should contain the following 4 DataFrame objects:\n\n\nfrom biopandas.pdb import PandasPdb\nppdb = PandasPdb()\nppdb.read_pdb('./data/3eiy.pdb')\nppdb.df.keys()\n\n\n\n\ndict_keys(['HETATM', 'ANISOU', 'ATOM', 'OTHERS'])\n\n\n\n\n\n'ATOM': contains the entries from the ATOM coordinate section\n\n\n'ATOM':  ... entries from the \"HETATM\" coordinate section    \n\n\n'ANISOU': ... entries from the \"ANISOU\" coordinate section \n\n\n'OTHERS': Everything else that is \nnot\n a 'ATOM', 'HETATM', or 'ANISOU' entry\n\n\n\n\n\n\nThe columns of the 'HETATM' DataFrame are indentical to the 'ATOM' DataFrame that we've seen earlier:\n\n\nppdb.df['HETATM'].head(2)\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \nrecord_name\n\n      \natom_number\n\n      \nblank_1\n\n      \natom_name\n\n      \n...\n\n      \nsegment_id\n\n      \nelement_symbol\n\n      \ncharge\n\n      \nline_idx\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \nHETATM\n\n      \n1332\n\n      \n\n      \nK\n\n      \n...\n\n      \n\n      \nK\n\n      \nNaN\n\n      \n1940\n\n    \n\n    \n\n      \n1\n\n      \nHETATM\n\n      \n1333\n\n      \n\n      \nNA\n\n      \n...\n\n      \n\n      \nNA\n\n      \nNaN\n\n      \n1941\n\n    \n\n  \n\n\n\n\n2 rows \u00d7 21 columns\n\n\n\n\n\n\n\nNote that \"ANISOU\" entries are handled a bit differently as specified at \nhttp://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM\n.\n\n\nppdb.df['ANISOU'].head(2)\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \nrecord_name\n\n      \natom_number\n\n      \nblank_1\n\n      \natom_name\n\n      \n...\n\n      \nblank_4\n\n      \nelement_symbol\n\n      \ncharge\n\n      \nline_idx\n\n    \n\n  \n\n  \n\n  \n\n\n\n\n0 rows \u00d7 21 columns\n\n\n\n\n\nNot every PDB file contains ANISOU entries (similarly, some PDB files may only contain HETATM or ATOM entries). If records are basent, the DataFrame will be empty as show above.\n\n\nppdb.df['ANISOU'].empty\n\n\n\n\nTrue\n\n\n\nSince the DataFrames are fairly wide, let's us take a look at the columns by accessing the DataFrame's \ncolumn\n attribute:\n\n\nppdb.df['ANISOU'].columns\n\n\n\n\nIndex(['record_name', 'atom_number', 'blank_1', 'atom_name', 'alt_loc', 'residue_name', 'blank_2', 'chain_id', 'residue_number', 'insertion', 'blank_3', 'U(1,1)', 'U(2,2)', 'U(3,3)', 'U(1,2)', 'U(1,3)', 'U(2,3)', 'blank_4', 'element_symbol', 'charge', 'line_idx'], dtype='object')\n\n\n\nANISOU records are very similar to ATOM/HETATM records. In fact, the columns 7 - 27 and 73 - 80 are identical to their corresponding ATOM/HETATM records, which means that the 'ANISOU' DataFrame doesn't have the following entries:\n\n\nset(ppdb.df['ATOM'].columns).difference(set(ppdb.df['ANISOU'].columns))\n\n\n\n\n{'b_factor', 'occupancy', 'segment_id', 'x_coord', 'y_coord', 'z_coord'}\n\n\n\nInstead, the \"ANISOU\" DataFrame contains the anisotropic temperature factors \"U(-,-)\" -- note that these are scaled by a factor of $10^4$ ($\\text{Angstroms}^2$) by convention.\n\n\nset(ppdb.df['ANISOU'].columns).difference(set(ppdb.df['ATOM'].columns))\n\n\n\n\n{'U(1,1)', 'U(1,2)', 'U(1,3)', 'U(2,2)', 'U(2,3)', 'U(3,3)'}\n\n\n\n\n\n\n\nAh, another interesting thing to mention is that the columns already come with the types you'd expect (where \nobject\n essentially \"means\" \nstr\n here):\n\n\nppdb.df['ATOM'].dtypes\n\n\n\n\nrecord_name        object\natom_number         int64\nblank_1            object\natom_name          object\nalt_loc            object\nresidue_name       object\nblank_2            object\nchain_id           object\nresidue_number      int64\ninsertion          object\nblank_3            object\nx_coord           float64\ny_coord           float64\nz_coord           float64\noccupancy         float64\nb_factor          float64\nblank_4            object\nsegment_id         object\nelement_symbol     object\ncharge            float64\nline_idx            int64\ndtype: object\n\n\n\n\n\nTypically, all good things come in threes, however, there is a 4th DataFrame, an'OTHER' DataFrame, which contains everything that wasn't parsed as 'ATOM', 'HETATM', or 'ANISOU' coordinate section:\n\n\nppdb.df['OTHERS'].head(5)\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \nrecord_name\n\n      \nentry\n\n      \nline_idx\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \nHEADER\n\n      \nHYDROLASE                               17...\n\n      \n0\n\n    \n\n    \n\n      \n1\n\n      \nTITLE\n\n      \nCRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHA...\n\n      \n1\n\n    \n\n    \n\n      \n2\n\n      \nTITLE\n\n      \n2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE\n\n      \n2\n\n    \n\n    \n\n      \n3\n\n      \nCOMPND\n\n      \nMOL_ID: 1;\n\n      \n3\n\n    \n\n    \n\n      \n4\n\n      \nCOMPND\n\n      \n2 MOLECULE: INORGANIC PYROPHOSPHATASE;\n\n      \n4\n\n    \n\n  \n\n\n\n\n\n\n\nAlthough these 'OTHER' entries are typically less useful for structure-related computations, you may still want to take a look at them to get a short summary of the PDB structure and learn about it's potential quirks and gotchas (typically listed in the REMARKs section). Lastly, the \"OTHERS\" DataFrame comes in handy if we want to reconstruct the structure as PDB file as we will see later (note the \nline_idx\n columns in all of the DataFrames).\n\n\nWorking with PDB DataFrames\n\n\nIn the previous sections, we've seen how to load PDB structures into DataFrames, and how to access them. Now, let's talk about manipulating PDB files in DataFrames.\n\n\nfrom biopandas.pdb import PandasPdb\nppdb = PandasPdb()\nppdb.read_pdb('./data/3eiy.pdb.gz')\nppdb.df['ATOM'].head()\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \nrecord_name\n\n      \natom_number\n\n      \nblank_1\n\n      \natom_name\n\n      \n...\n\n      \nsegment_id\n\n      \nelement_symbol\n\n      \ncharge\n\n      \nline_idx\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \nATOM\n\n      \n1\n\n      \n\n      \nN\n\n      \n...\n\n      \n\n      \nN\n\n      \nNaN\n\n      \n609\n\n    \n\n    \n\n      \n1\n\n      \nATOM\n\n      \n2\n\n      \n\n      \nCA\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n610\n\n    \n\n    \n\n      \n2\n\n      \nATOM\n\n      \n3\n\n      \n\n      \nC\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n611\n\n    \n\n    \n\n      \n3\n\n      \nATOM\n\n      \n4\n\n      \n\n      \nO\n\n      \n...\n\n      \n\n      \nO\n\n      \nNaN\n\n      \n612\n\n    \n\n    \n\n      \n4\n\n      \nATOM\n\n      \n5\n\n      \n\n      \nCB\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n613\n\n    \n\n  \n\n\n\n\n5 rows \u00d7 21 columns\n\n\n\n\n\nOkay, there's actually not \nthat\n much to say ... \n\nOnce we have our PDB file in the DataFrame format, we have the whole convenience of \npandas\n right there at our fingertips.\n\n\nFor example, let's get all Proline residues:\n\n\nppdb.df['ATOM'][ppdb.df['ATOM']['residue_name'] == 'PRO'].head()\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \nrecord_name\n\n      \natom_number\n\n      \nblank_1\n\n      \natom_name\n\n      \n...\n\n      \nsegment_id\n\n      \nelement_symbol\n\n      \ncharge\n\n      \nline_idx\n\n    \n\n  \n\n  \n\n    \n\n      \n38\n\n      \nATOM\n\n      \n39\n\n      \n\n      \nN\n\n      \n...\n\n      \n\n      \nN\n\n      \nNaN\n\n      \n647\n\n    \n\n    \n\n      \n39\n\n      \nATOM\n\n      \n40\n\n      \n\n      \nCA\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n648\n\n    \n\n    \n\n      \n40\n\n      \nATOM\n\n      \n41\n\n      \n\n      \nC\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n649\n\n    \n\n    \n\n      \n41\n\n      \nATOM\n\n      \n42\n\n      \n\n      \nO\n\n      \n...\n\n      \n\n      \nO\n\n      \nNaN\n\n      \n650\n\n    \n\n    \n\n      \n42\n\n      \nATOM\n\n      \n43\n\n      \n\n      \nCB\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n651\n\n    \n\n  \n\n\n\n\n5 rows \u00d7 21 columns\n\n\n\n\n\nOr main chain atoms:\n\n\nppdb.df['ATOM'][ppdb.df['ATOM']['atom_name'] == 'C'].head()\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \nrecord_name\n\n      \natom_number\n\n      \nblank_1\n\n      \natom_name\n\n      \n...\n\n      \nsegment_id\n\n      \nelement_symbol\n\n      \ncharge\n\n      \nline_idx\n\n    \n\n  \n\n  \n\n    \n\n      \n2\n\n      \nATOM\n\n      \n3\n\n      \n\n      \nC\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n611\n\n    \n\n    \n\n      \n8\n\n      \nATOM\n\n      \n9\n\n      \n\n      \nC\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n617\n\n    \n\n    \n\n      \n19\n\n      \nATOM\n\n      \n20\n\n      \n\n      \nC\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n628\n\n    \n\n    \n\n      \n25\n\n      \nATOM\n\n      \n26\n\n      \n\n      \nC\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n634\n\n    \n\n    \n\n      \n33\n\n      \nATOM\n\n      \n34\n\n      \n\n      \nC\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n642\n\n    \n\n  \n\n\n\n\n5 rows \u00d7 21 columns\n\n\n\n\n\nIt's also easy to strip our coordinate section from hydrogen atoms if there are any ...\n\n\nppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H'].head()\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \nrecord_name\n\n      \natom_number\n\n      \nblank_1\n\n      \natom_name\n\n      \n...\n\n      \nsegment_id\n\n      \nelement_symbol\n\n      \ncharge\n\n      \nline_idx\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \nATOM\n\n      \n1\n\n      \n\n      \nN\n\n      \n...\n\n      \n\n      \nN\n\n      \nNaN\n\n      \n609\n\n    \n\n    \n\n      \n1\n\n      \nATOM\n\n      \n2\n\n      \n\n      \nCA\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n610\n\n    \n\n    \n\n      \n2\n\n      \nATOM\n\n      \n3\n\n      \n\n      \nC\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n611\n\n    \n\n    \n\n      \n3\n\n      \nATOM\n\n      \n4\n\n      \n\n      \nO\n\n      \n...\n\n      \n\n      \nO\n\n      \nNaN\n\n      \n612\n\n    \n\n    \n\n      \n4\n\n      \nATOM\n\n      \n5\n\n      \n\n      \nCB\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n613\n\n    \n\n  \n\n\n\n\n5 rows \u00d7 21 columns\n\n\n\n\n\nOr, let's compute the average temperature factor of our protein main chain:\n\n\nmainchain = ppdb.df['ATOM'][(ppdb.df['ATOM']['atom_name'] == 'C') | \n                            (ppdb.df['ATOM']['atom_name'] == 'O') | \n                            (ppdb.df['ATOM']['atom_name'] == 'N') | \n                            (ppdb.df['ATOM']['atom_name'] == 'CA')]\n\nbfact_mc_avg = mainchain['b_factor'].mean()\nprint('Average B-Factor [Main Chain]: %.2f' % bfact_mc_avg)\n\n\n\n\nAverage B-Factor [Main Chain]: 28.83\n\n\n\nPlotting\n\n\nSince we are using pandas under the hood, which in turns uses matplotlib under the hood, we can produce quick summary plots of our PDB structures relatively conveniently:\n\n\nfrom biopandas.pdb import PandasPdb\nppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz')\n\n\n\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom matplotlib import style\nstyle.use('ggplot')\n\n\n\n\nppdb.df['ATOM']['b_factor'].plot(kind='hist')\nplt.title('Distribution of B-Factors')\nplt.xlabel('B-factor')\nplt.ylabel('count')\nplt.show()\n\n\n\n\n\n\nppdb.df['ATOM']['b_factor'].plot(kind='line')\nplt.title('B-Factors Along the Amino Acid Chain')\nplt.xlabel('Residue Number')\nplt.ylabel('B-factor in $A^2$')\nplt.show()\n\n\n\n\n\n\nppdb.df['ATOM']['element_symbol'].value_counts().plot(kind='bar')\nplt.title('Distribution of Atom Types')\nplt.xlabel('elements')\nplt.ylabel('count')\nplt.show()\n\n\n\n\n\n\nComputing the Root Mean Square Deviation\n\n\nBioPandas also comes with certain convenience functions, for example, ...\n\n\nThe Root-mean-square deviation (RMSD) is simply a measure of the average distance between atoms of 2 protein or ligand structures. This calculation of the Cartesian error follows the equation:\n\n\n$$RMSD(a, b) = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} \\big((a_{ix})^2 + (a_{iy})^2 + (a_{iz})^2 \\big)} \\\\\n= \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} || a_i + b_i||_2^2}$$\n\n\nSo, assuming that the we have the following 2 conformations of a ligand molecule\n\n\n\n\nwe can compute the RMSD as follows:\n\n\nfrom biopandas.pdb import PandasPdb\n\nl_1 = PandasPdb().read_pdb('./data/lig_conf_1.pdb')\nl_2 = PandasPdb().read_pdb('./data/lig_conf_2.pdb')\nr = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'],\n                   s=None) # all atoms, including hydrogens\nprint('RMSD: %.4f Angstrom' % r)\n\n\n\n\nRMSD: 2.6444 Angstrom\n\n\n\nr = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], \n                   s='carbon') # carbon atoms only\nprint('RMSD: %.4f Angstrom' % r)\n\n\n\n\nRMSD: 3.1405 Angstrom\n\n\n\nr = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], \n                   s='heavy') # heavy atoms only\nprint('RMSD: %.4f Angstrom' % r)\n\n\n\n\nRMSD: 1.9959 Angstrom\n\n\n\nSimilarly, we can compute the RMSD between 2 related protein structures:\n\n\n\n\nThe hydrogen-free RMSD:\n\n\np_1 = PandasPdb().read_pdb('./data/1t48_995.pdb')\np_2 = PandasPdb().read_pdb('./data/1t49_995.pdb')\nr = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='heavy')\nprint('RMSD: %.4f Angstrom' % r)\n\n\n\n\nRMSD: 0.7377 Angstrom\n\n\n\nOr the RMSD between the main chains only:\n\n\np_1 = PandasPdb().read_pdb('./data/1t48_995.pdb')\np_2 = PandasPdb().read_pdb('./data/1t49_995.pdb')\nr = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='main chain')\nprint('RMSD: %.4f Angstrom' % r)\n\n\n\n\nRMSD: 0.4781 Angstrom\n\n\n\n\n\nFiltering PDBs by Distance\n\n\nWe can use the \ndistance\n method to compute the distance between each atom (or a subset of atoms) in our data frame and a three-dimensional reference point. For example:\n\n\np_1 = PandasPdb().read_pdb('./data/3eiy.pdb')\n\nreference_point = (9.362, 41.410, 10.542)\ndistances = p_1.distance(xyz=reference_point, record='ATOM')\n\n\n\n\nThe distance method returns a Pandas Series object:\n\n\ndistances.head()\n\n\n\n\n0    19.267419\n1    18.306060\n2    16.976934\n3    16.902897\n4    18.124171\ndtype: float64\n\n\n\nAnd we can use this \nSeries\n object, for instance, to select certain atoms in our DataFrame that fall within a desired distance threshold. For example, let's select all atoms that are within 7A of our reference point: \n\n\nall_within_7A = p_1.df['ATOM'][distances < 7.0]\nall_within_7A.tail()\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \nrecord_name\n\n      \natom_number\n\n      \nblank_1\n\n      \natom_name\n\n      \n...\n\n      \nsegment_id\n\n      \nelement_symbol\n\n      \ncharge\n\n      \nline_idx\n\n    \n\n  \n\n  \n\n    \n\n      \n786\n\n      \nATOM\n\n      \n787\n\n      \n\n      \nCB\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n1395\n\n    \n\n    \n\n      \n787\n\n      \nATOM\n\n      \n788\n\n      \n\n      \nCG\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n1396\n\n    \n\n    \n\n      \n788\n\n      \nATOM\n\n      \n789\n\n      \n\n      \nCD1\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n1397\n\n    \n\n    \n\n      \n789\n\n      \nATOM\n\n      \n790\n\n      \n\n      \nCD2\n\n      \n...\n\n      \n\n      \nC\n\n      \nNaN\n\n      \n1398\n\n    \n\n    \n\n      \n790\n\n      \nATOM\n\n      \n791\n\n      \n\n      \nN\n\n      \n...\n\n      \n\n      \nN\n\n      \nNaN\n\n      \n1399\n\n    \n\n  \n\n\n\n\n5 rows \u00d7 21 columns\n\n\n\n\n\nVisualized in PyMOL, this subset (yellow surface) would look as follows:\n\n\n\n\nConverting Amino Acid codes from 3- to 1-letter codes\n\n\nResidues in the \nresidue_name\n field can be converted into 1-letter amino acid codes, which may be useful for further sequence analysis, for example, pair-wise or multiple sequence alignments:\n\n\nfrom biopandas.pdb import PandasPdb\nppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz')\nppdb.amino3to1()\n# By default, `amino3to1` returns a pandas Series object,\n# and to convert it into a Python list, you can wrap it in list\n# constructor, e.g.,\n# `list(ppdb.amino3to1())`\n\n\n\n\n0       S\n6       F\n17      S\n23      N\n31      V\n38      P\n45      A\n50      G\n54      K\n63      D\n71      L\n79      P\n86      Q\n95      D\n103     F\n114     N\n122     V\n129     I\n137     I\n145     E\n154     I\n162     P\n169     A\n174     Q\n183     S\n189     E\n198     P\n205     V\n212     K\n221     Y\n       ..\n1100    E\n1109    K\n1114    G\n1118    K\n1127    W\n1141    V\n1148    K\n1153    V\n1160    E\n1169    G\n1173    W\n1187    D\n1195    G\n1199    I\n1207    D\n1215    A\n1220    A\n1225    H\n1235    K\n1244    E\n1253    I\n1261    T\n1268    D\n1276    G\n1280    V\n1287    A\n1292    N\n1300    F\n1311    K\n1320    K\nName: residue_name, dtype: object\n\n\n\nWrapping it up - Saving PDB structures\n\n\nFinally, let's talk about how to get the PDB structures out of the DataFrame format back into the beloved .pdb format.\n\n\nLet's say we loaded a PDB structure, removed it from it's hydrogens:\n\n\nfrom biopandas.pdb import PandasPdb\nppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz')\nppdb.df['ATOM'] = ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H']\n\n\n\n\nWe can save the file using the \nPandasPdb.to_pdb\n method:\n\n\nppdb.to_pdb(path='./data/3eiy_stripped.pdb', \n            records=None, \n            gz=False, \n            append_newline=True)\n\n\n\n\nBy default, all records (that is, 'ATOM', 'HETATM', 'OTHERS', 'ANISOU') are written if we set \nrecords=None\n. Alternatively, let's say we want to get rid of the 'ANISOU' entries and produce a compressed gzip archive of our PDB structure:\n\n\nppdb.to_pdb(path='./data/3eiy_stripped.pdb.gz', \n            records=['ATOM', 'HETATM', 'OTHERS'], \n            gz=True, \n            append_newline=True)",
            "title": "Working with PDB Structures in DataFrames"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#working-with-pdb-structures-in-dataframes",
            "text": "",
            "title": "Working with PDB Structures in DataFrames"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#loading-pdb-files",
            "text": "There are 2 1/2 ways to load a PDB structure into a  PandasPdb  object.",
            "title": "Loading PDB Files"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#1",
            "text": "PDB files can be directly fetched from The Protein Data Bank at  http://www.rcsb.org  via its unique 4-letter after initializing a new  PandasPdb  object and calling the  fetch_pdb  method:  from biopandas.pdb import PandasPdb\n\n# Initialize a new PandasPdb object\n# and fetch the PDB file from rcsb.org\nppdb = PandasPdb().fetch_pdb('3eiy')",
            "title": "1"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#2-a",
            "text": "Alternatively, we can load PDB files from local directories as regular PDB files using  read_pdb :  ppdb.read_pdb('./data/3eiy.pdb')  <biopandas.pdb.pandas_pdb.PandasPdb at 0x106795898>",
            "title": "2 a)"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#2-b",
            "text": "Or, we can load them from gzip archives like so (note that the file must end with a '.gz' suffix in order to be recognized as a gzip file):  ppdb.read_pdb('./data/3eiy.pdb.gz')  <biopandas.pdb.pandas_pdb.PandasPdb at 0x106795898>  After the file was succesfully loaded, we have access to the following attributes:  print('PDB Code: %s' % ppdb.code)\nprint('PDB Header Line: %s' % ppdb.header)\nprint('\\nRaw PDB file contents:\\n\\n%s\\n...' % ppdb.pdb_text[:1000])  PDB Code: 3eiy\nPDB Header Line:     HYDROLASE                               17-SEP-08   3EIY\n\nRaw PDB file contents:\n\nHEADER    HYDROLASE                               17-SEP-08   3EIY              \nTITLE     CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHATASE FROM BURKHOLDERIA      \nTITLE    2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE                                \nCOMPND    MOL_ID: 1;                                                            \nCOMPND   2 MOLECULE: INORGANIC PYROPHOSPHATASE;                                 \nCOMPND   3 CHAIN: A;                                                            \nCOMPND   4 EC: 3.6.1.1;                                                         \nCOMPND   5 ENGINEERED: YES                                                      \nSOURCE    MOL_ID: 1;                                                            \nSOURCE   2 ORGANISM_SCIENTIFIC: BURKHOLDERIA PSEUDOMALLEI 1710B;                \nSOURCE   3 ORGANISM_TAXID: 320372;                                              \nSOURCE   4 GENE: PPA, BURPS1710B_1237;                                          \nSOURCE   5 EXPRESSION_SYSTEM\n...  The most interesting / useful attribute is the  PandasPdb.df  DataFrame dictionary though, which gives us access to the PDB files as pandas DataFrames. Let's print the first 3 lines from the  ATOM  coordinate section to see how it looks like:  ppdb.df['ATOM'].head(3)   \n   \n     \n       \n       record_name \n       atom_number \n       blank_1 \n       atom_name \n       ... \n       segment_id \n       element_symbol \n       charge \n       line_idx \n     \n   \n   \n     \n       0 \n       ATOM \n       1 \n       \n       N \n       ... \n       \n       N \n       NaN \n       609 \n     \n     \n       1 \n       ATOM \n       2 \n       \n       CA \n       ... \n       \n       C \n       NaN \n       610 \n     \n     \n       2 \n       ATOM \n       3 \n       \n       C \n       ... \n       \n       C \n       NaN \n       611 \n     \n     3 rows \u00d7 21 columns   But more on that in the next section.",
            "title": "2 b)"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#looking-at-pdbs-in-dataframes",
            "text": "PDB files are parsed according to the  PDB file format description . More specifically, BioPandas reads the columns of the ATOM and HETATM sections as shown in the following excerpt from  http://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM .     COLUMNS  DATA TYPE  CONTENTS  biopandas column name      1 - 6  Record name  \"ATOM\"  record_name    7 - 11  Integer  Atom serial number.  atom_number    12    blank_1    13 - 16  Atom  Atom name.  atom_name    17  Character  Alternate location indicator.  alt_loc    18 - 20  Residue name  Residue name.  residue_name    21    blank_2    22  Character  Chain identifier.  chain_id    23 - 26  Integer  Residue sequence number.  residue_number    27  AChar  Code for insertion of residues.  insertion    28 - 30    blank_3    31 - 38  Real(8.3)  Orthogonal coordinates for X in Angstroms.  x_coord    39 - 46  Real(8.3)  Orthogonal coordinates for Y in Angstroms.  y_coord    47 - 54  Real(8.3)  Orthogonal coordinates for Z in Angstroms.  z_coord    55 - 60  Real(6.2)  Occupancy.  occupancy    61 - 66  Real(6.2)  Temperature factor (Default = 0.0).  bfactor    67-72    blank_4    73 - 76  LString(4)  Segment identifier, left-justified.  segment_id    77 - 78  LString(2)  Element symbol, right-justified.  element_symbol    79 - 80  LString(2)  Charge on the atom.  charge     Below is an example of how this would look like in an actual PDB file:  Example: \n         1         2         3         4         5         6         7         8\n12345678901234567890123456789012345678901234567890123456789012345678901234567890\nATOM    145  N   VAL A  25      32.433  16.336  57.540  1.00 11.92      A1   N\nATOM    146  CA  VAL A  25      31.132  16.439  58.160  1.00 11.85      A1   C\nATOM    147  C   VAL A  25      30.447  15.105  58.363  1.00 12.34      A1   C\nATOM    148  O   VAL A  25      29.520  15.059  59.174  1.00 15.65      A1   O\nATOM    149  CB AVAL A  25      30.385  17.437  57.230  0.28 13.88      A1   C\nATOM    150  CB BVAL A  25      30.166  17.399  57.373  0.72 15.41      A1   C\nATOM    151  CG1AVAL A  25      28.870  17.401  57.336  0.28 12.64      A1   C\nATOM    152  CG1BVAL A  25      30.805  18.788  57.449  0.72 15.11      A1   C\nATOM    153  CG2AVAL A  25      30.835  18.826  57.661  0.28 13.58      A1   C\nATOM    154  CG2BVAL A  25      29.909  16.996  55.922  0.72 13.25      A1   C  After loading a PDB file from rcsb.org or our local drive, the  PandasPdb.df  attribute should contain the following 4 DataFrame objects:  from biopandas.pdb import PandasPdb\nppdb = PandasPdb()\nppdb.read_pdb('./data/3eiy.pdb')\nppdb.df.keys()  dict_keys(['HETATM', 'ANISOU', 'ATOM', 'OTHERS'])   'ATOM': contains the entries from the ATOM coordinate section  'ATOM':  ... entries from the \"HETATM\" coordinate section      'ANISOU': ... entries from the \"ANISOU\" coordinate section   'OTHERS': Everything else that is  not  a 'ATOM', 'HETATM', or 'ANISOU' entry    The columns of the 'HETATM' DataFrame are indentical to the 'ATOM' DataFrame that we've seen earlier:  ppdb.df['HETATM'].head(2)   \n   \n     \n       \n       record_name \n       atom_number \n       blank_1 \n       atom_name \n       ... \n       segment_id \n       element_symbol \n       charge \n       line_idx \n     \n   \n   \n     \n       0 \n       HETATM \n       1332 \n       \n       K \n       ... \n       \n       K \n       NaN \n       1940 \n     \n     \n       1 \n       HETATM \n       1333 \n       \n       NA \n       ... \n       \n       NA \n       NaN \n       1941 \n     \n     2 rows \u00d7 21 columns    Note that \"ANISOU\" entries are handled a bit differently as specified at  http://deposit.rcsb.org/adit/docs/pdb_atom_format.html#ATOM .  ppdb.df['ANISOU'].head(2)   \n   \n     \n       \n       record_name \n       atom_number \n       blank_1 \n       atom_name \n       ... \n       blank_4 \n       element_symbol \n       charge \n       line_idx \n     \n   \n   \n     0 rows \u00d7 21 columns   Not every PDB file contains ANISOU entries (similarly, some PDB files may only contain HETATM or ATOM entries). If records are basent, the DataFrame will be empty as show above.  ppdb.df['ANISOU'].empty  True  Since the DataFrames are fairly wide, let's us take a look at the columns by accessing the DataFrame's  column  attribute:  ppdb.df['ANISOU'].columns  Index(['record_name', 'atom_number', 'blank_1', 'atom_name', 'alt_loc', 'residue_name', 'blank_2', 'chain_id', 'residue_number', 'insertion', 'blank_3', 'U(1,1)', 'U(2,2)', 'U(3,3)', 'U(1,2)', 'U(1,3)', 'U(2,3)', 'blank_4', 'element_symbol', 'charge', 'line_idx'], dtype='object')  ANISOU records are very similar to ATOM/HETATM records. In fact, the columns 7 - 27 and 73 - 80 are identical to their corresponding ATOM/HETATM records, which means that the 'ANISOU' DataFrame doesn't have the following entries:  set(ppdb.df['ATOM'].columns).difference(set(ppdb.df['ANISOU'].columns))  {'b_factor', 'occupancy', 'segment_id', 'x_coord', 'y_coord', 'z_coord'}  Instead, the \"ANISOU\" DataFrame contains the anisotropic temperature factors \"U(-,-)\" -- note that these are scaled by a factor of $10^4$ ($\\text{Angstroms}^2$) by convention.  set(ppdb.df['ANISOU'].columns).difference(set(ppdb.df['ATOM'].columns))  {'U(1,1)', 'U(1,2)', 'U(1,3)', 'U(2,2)', 'U(2,3)', 'U(3,3)'}    Ah, another interesting thing to mention is that the columns already come with the types you'd expect (where  object  essentially \"means\"  str  here):  ppdb.df['ATOM'].dtypes  record_name        object\natom_number         int64\nblank_1            object\natom_name          object\nalt_loc            object\nresidue_name       object\nblank_2            object\nchain_id           object\nresidue_number      int64\ninsertion          object\nblank_3            object\nx_coord           float64\ny_coord           float64\nz_coord           float64\noccupancy         float64\nb_factor          float64\nblank_4            object\nsegment_id         object\nelement_symbol     object\ncharge            float64\nline_idx            int64\ndtype: object   Typically, all good things come in threes, however, there is a 4th DataFrame, an'OTHER' DataFrame, which contains everything that wasn't parsed as 'ATOM', 'HETATM', or 'ANISOU' coordinate section:  ppdb.df['OTHERS'].head(5)   \n   \n     \n       \n       record_name \n       entry \n       line_idx \n     \n   \n   \n     \n       0 \n       HEADER \n       HYDROLASE                               17... \n       0 \n     \n     \n       1 \n       TITLE \n       CRYSTAL STRUCTURE OF INORGANIC PYROPHOSPHA... \n       1 \n     \n     \n       2 \n       TITLE \n       2 PSEUDOMALLEI WITH BOUND PYROPHOSPHATE \n       2 \n     \n     \n       3 \n       COMPND \n       MOL_ID: 1; \n       3 \n     \n     \n       4 \n       COMPND \n       2 MOLECULE: INORGANIC PYROPHOSPHATASE; \n       4 \n     \n      Although these 'OTHER' entries are typically less useful for structure-related computations, you may still want to take a look at them to get a short summary of the PDB structure and learn about it's potential quirks and gotchas (typically listed in the REMARKs section). Lastly, the \"OTHERS\" DataFrame comes in handy if we want to reconstruct the structure as PDB file as we will see later (note the  line_idx  columns in all of the DataFrames).",
            "title": "Looking at PDBs in DataFrames"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#working-with-pdb-dataframes",
            "text": "In the previous sections, we've seen how to load PDB structures into DataFrames, and how to access them. Now, let's talk about manipulating PDB files in DataFrames.  from biopandas.pdb import PandasPdb\nppdb = PandasPdb()\nppdb.read_pdb('./data/3eiy.pdb.gz')\nppdb.df['ATOM'].head()   \n   \n     \n       \n       record_name \n       atom_number \n       blank_1 \n       atom_name \n       ... \n       segment_id \n       element_symbol \n       charge \n       line_idx \n     \n   \n   \n     \n       0 \n       ATOM \n       1 \n       \n       N \n       ... \n       \n       N \n       NaN \n       609 \n     \n     \n       1 \n       ATOM \n       2 \n       \n       CA \n       ... \n       \n       C \n       NaN \n       610 \n     \n     \n       2 \n       ATOM \n       3 \n       \n       C \n       ... \n       \n       C \n       NaN \n       611 \n     \n     \n       3 \n       ATOM \n       4 \n       \n       O \n       ... \n       \n       O \n       NaN \n       612 \n     \n     \n       4 \n       ATOM \n       5 \n       \n       CB \n       ... \n       \n       C \n       NaN \n       613 \n     \n     5 rows \u00d7 21 columns   Okay, there's actually not  that  much to say ...  \nOnce we have our PDB file in the DataFrame format, we have the whole convenience of  pandas  right there at our fingertips.  For example, let's get all Proline residues:  ppdb.df['ATOM'][ppdb.df['ATOM']['residue_name'] == 'PRO'].head()   \n   \n     \n       \n       record_name \n       atom_number \n       blank_1 \n       atom_name \n       ... \n       segment_id \n       element_symbol \n       charge \n       line_idx \n     \n   \n   \n     \n       38 \n       ATOM \n       39 \n       \n       N \n       ... \n       \n       N \n       NaN \n       647 \n     \n     \n       39 \n       ATOM \n       40 \n       \n       CA \n       ... \n       \n       C \n       NaN \n       648 \n     \n     \n       40 \n       ATOM \n       41 \n       \n       C \n       ... \n       \n       C \n       NaN \n       649 \n     \n     \n       41 \n       ATOM \n       42 \n       \n       O \n       ... \n       \n       O \n       NaN \n       650 \n     \n     \n       42 \n       ATOM \n       43 \n       \n       CB \n       ... \n       \n       C \n       NaN \n       651 \n     \n     5 rows \u00d7 21 columns   Or main chain atoms:  ppdb.df['ATOM'][ppdb.df['ATOM']['atom_name'] == 'C'].head()   \n   \n     \n       \n       record_name \n       atom_number \n       blank_1 \n       atom_name \n       ... \n       segment_id \n       element_symbol \n       charge \n       line_idx \n     \n   \n   \n     \n       2 \n       ATOM \n       3 \n       \n       C \n       ... \n       \n       C \n       NaN \n       611 \n     \n     \n       8 \n       ATOM \n       9 \n       \n       C \n       ... \n       \n       C \n       NaN \n       617 \n     \n     \n       19 \n       ATOM \n       20 \n       \n       C \n       ... \n       \n       C \n       NaN \n       628 \n     \n     \n       25 \n       ATOM \n       26 \n       \n       C \n       ... \n       \n       C \n       NaN \n       634 \n     \n     \n       33 \n       ATOM \n       34 \n       \n       C \n       ... \n       \n       C \n       NaN \n       642 \n     \n     5 rows \u00d7 21 columns   It's also easy to strip our coordinate section from hydrogen atoms if there are any ...  ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H'].head()   \n   \n     \n       \n       record_name \n       atom_number \n       blank_1 \n       atom_name \n       ... \n       segment_id \n       element_symbol \n       charge \n       line_idx \n     \n   \n   \n     \n       0 \n       ATOM \n       1 \n       \n       N \n       ... \n       \n       N \n       NaN \n       609 \n     \n     \n       1 \n       ATOM \n       2 \n       \n       CA \n       ... \n       \n       C \n       NaN \n       610 \n     \n     \n       2 \n       ATOM \n       3 \n       \n       C \n       ... \n       \n       C \n       NaN \n       611 \n     \n     \n       3 \n       ATOM \n       4 \n       \n       O \n       ... \n       \n       O \n       NaN \n       612 \n     \n     \n       4 \n       ATOM \n       5 \n       \n       CB \n       ... \n       \n       C \n       NaN \n       613 \n     \n     5 rows \u00d7 21 columns   Or, let's compute the average temperature factor of our protein main chain:  mainchain = ppdb.df['ATOM'][(ppdb.df['ATOM']['atom_name'] == 'C') | \n                            (ppdb.df['ATOM']['atom_name'] == 'O') | \n                            (ppdb.df['ATOM']['atom_name'] == 'N') | \n                            (ppdb.df['ATOM']['atom_name'] == 'CA')]\n\nbfact_mc_avg = mainchain['b_factor'].mean()\nprint('Average B-Factor [Main Chain]: %.2f' % bfact_mc_avg)  Average B-Factor [Main Chain]: 28.83",
            "title": "Working with PDB DataFrames"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#plotting",
            "text": "Since we are using pandas under the hood, which in turns uses matplotlib under the hood, we can produce quick summary plots of our PDB structures relatively conveniently:  from biopandas.pdb import PandasPdb\nppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz')  %matplotlib inline\nimport matplotlib.pyplot as plt\nfrom matplotlib import style\nstyle.use('ggplot')  ppdb.df['ATOM']['b_factor'].plot(kind='hist')\nplt.title('Distribution of B-Factors')\nplt.xlabel('B-factor')\nplt.ylabel('count')\nplt.show()   ppdb.df['ATOM']['b_factor'].plot(kind='line')\nplt.title('B-Factors Along the Amino Acid Chain')\nplt.xlabel('Residue Number')\nplt.ylabel('B-factor in $A^2$')\nplt.show()   ppdb.df['ATOM']['element_symbol'].value_counts().plot(kind='bar')\nplt.title('Distribution of Atom Types')\nplt.xlabel('elements')\nplt.ylabel('count')\nplt.show()",
            "title": "Plotting"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#computing-the-root-mean-square-deviation",
            "text": "BioPandas also comes with certain convenience functions, for example, ...  The Root-mean-square deviation (RMSD) is simply a measure of the average distance between atoms of 2 protein or ligand structures. This calculation of the Cartesian error follows the equation:  $$RMSD(a, b) = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} \\big((a_{ix})^2 + (a_{iy})^2 + (a_{iz})^2 \\big)} \\\\\n= \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} || a_i + b_i||_2^2}$$  So, assuming that the we have the following 2 conformations of a ligand molecule   we can compute the RMSD as follows:  from biopandas.pdb import PandasPdb\n\nl_1 = PandasPdb().read_pdb('./data/lig_conf_1.pdb')\nl_2 = PandasPdb().read_pdb('./data/lig_conf_2.pdb')\nr = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'],\n                   s=None) # all atoms, including hydrogens\nprint('RMSD: %.4f Angstrom' % r)  RMSD: 2.6444 Angstrom  r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], \n                   s='carbon') # carbon atoms only\nprint('RMSD: %.4f Angstrom' % r)  RMSD: 3.1405 Angstrom  r = PandasPdb.rmsd(l_1.df['HETATM'], l_2.df['HETATM'], \n                   s='heavy') # heavy atoms only\nprint('RMSD: %.4f Angstrom' % r)  RMSD: 1.9959 Angstrom  Similarly, we can compute the RMSD between 2 related protein structures:   The hydrogen-free RMSD:  p_1 = PandasPdb().read_pdb('./data/1t48_995.pdb')\np_2 = PandasPdb().read_pdb('./data/1t49_995.pdb')\nr = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='heavy')\nprint('RMSD: %.4f Angstrom' % r)  RMSD: 0.7377 Angstrom  Or the RMSD between the main chains only:  p_1 = PandasPdb().read_pdb('./data/1t48_995.pdb')\np_2 = PandasPdb().read_pdb('./data/1t49_995.pdb')\nr = PandasPdb.rmsd(p_1.df['ATOM'], p_2.df['ATOM'], s='main chain')\nprint('RMSD: %.4f Angstrom' % r)  RMSD: 0.4781 Angstrom",
            "title": "Computing the Root Mean Square Deviation"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#filtering-pdbs-by-distance",
            "text": "We can use the  distance  method to compute the distance between each atom (or a subset of atoms) in our data frame and a three-dimensional reference point. For example:  p_1 = PandasPdb().read_pdb('./data/3eiy.pdb')\n\nreference_point = (9.362, 41.410, 10.542)\ndistances = p_1.distance(xyz=reference_point, record='ATOM')  The distance method returns a Pandas Series object:  distances.head()  0    19.267419\n1    18.306060\n2    16.976934\n3    16.902897\n4    18.124171\ndtype: float64  And we can use this  Series  object, for instance, to select certain atoms in our DataFrame that fall within a desired distance threshold. For example, let's select all atoms that are within 7A of our reference point:   all_within_7A = p_1.df['ATOM'][distances < 7.0]\nall_within_7A.tail()   \n   \n     \n       \n       record_name \n       atom_number \n       blank_1 \n       atom_name \n       ... \n       segment_id \n       element_symbol \n       charge \n       line_idx \n     \n   \n   \n     \n       786 \n       ATOM \n       787 \n       \n       CB \n       ... \n       \n       C \n       NaN \n       1395 \n     \n     \n       787 \n       ATOM \n       788 \n       \n       CG \n       ... \n       \n       C \n       NaN \n       1396 \n     \n     \n       788 \n       ATOM \n       789 \n       \n       CD1 \n       ... \n       \n       C \n       NaN \n       1397 \n     \n     \n       789 \n       ATOM \n       790 \n       \n       CD2 \n       ... \n       \n       C \n       NaN \n       1398 \n     \n     \n       790 \n       ATOM \n       791 \n       \n       N \n       ... \n       \n       N \n       NaN \n       1399 \n     \n     5 rows \u00d7 21 columns   Visualized in PyMOL, this subset (yellow surface) would look as follows:",
            "title": "Filtering PDBs by Distance"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#converting-amino-acid-codes-from-3-to-1-letter-codes",
            "text": "Residues in the  residue_name  field can be converted into 1-letter amino acid codes, which may be useful for further sequence analysis, for example, pair-wise or multiple sequence alignments:  from biopandas.pdb import PandasPdb\nppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz')\nppdb.amino3to1()\n# By default, `amino3to1` returns a pandas Series object,\n# and to convert it into a Python list, you can wrap it in list\n# constructor, e.g.,\n# `list(ppdb.amino3to1())`  0       S\n6       F\n17      S\n23      N\n31      V\n38      P\n45      A\n50      G\n54      K\n63      D\n71      L\n79      P\n86      Q\n95      D\n103     F\n114     N\n122     V\n129     I\n137     I\n145     E\n154     I\n162     P\n169     A\n174     Q\n183     S\n189     E\n198     P\n205     V\n212     K\n221     Y\n       ..\n1100    E\n1109    K\n1114    G\n1118    K\n1127    W\n1141    V\n1148    K\n1153    V\n1160    E\n1169    G\n1173    W\n1187    D\n1195    G\n1199    I\n1207    D\n1215    A\n1220    A\n1225    H\n1235    K\n1244    E\n1253    I\n1261    T\n1268    D\n1276    G\n1280    V\n1287    A\n1292    N\n1300    F\n1311    K\n1320    K\nName: residue_name, dtype: object",
            "title": "Converting Amino Acid codes from 3- to 1-letter codes"
        },
        {
            "location": "/tutorials/Working_with_PDB_Structures_in_DataFrames/#wrapping-it-up-saving-pdb-structures",
            "text": "Finally, let's talk about how to get the PDB structures out of the DataFrame format back into the beloved .pdb format.  Let's say we loaded a PDB structure, removed it from it's hydrogens:  from biopandas.pdb import PandasPdb\nppdb = PandasPdb().read_pdb('./data/3eiy.pdb.gz')\nppdb.df['ATOM'] = ppdb.df['ATOM'][ppdb.df['ATOM']['element_symbol'] != 'H']  We can save the file using the  PandasPdb.to_pdb  method:  ppdb.to_pdb(path='./data/3eiy_stripped.pdb', \n            records=None, \n            gz=False, \n            append_newline=True)  By default, all records (that is, 'ATOM', 'HETATM', 'OTHERS', 'ANISOU') are written if we set  records=None . Alternatively, let's say we want to get rid of the 'ANISOU' entries and produce a compressed gzip archive of our PDB structure:  ppdb.to_pdb(path='./data/3eiy_stripped.pdb.gz', \n            records=['ATOM', 'HETATM', 'OTHERS'], \n            gz=True, \n            append_newline=True)",
            "title": "Wrapping it up - Saving PDB structures"
        },
        {
            "location": "/tutorials/Working_with_MOL2_Structures_in_DataFrames/",
            "text": "Working with MOL2 Structures in DataFrames\n\n\nThe Tripos MOL2 format is a common format for working with small molecules. In this tutorial, we will go over some examples that illustrate how we can use Biopandas' MOL2 DataFrames to analyze molecules conveniently.\n\n\nLoading MOL2 Files\n\n\nUsing the \nread_mol2\n method, we can read MOL2 files from standard .mol2 text files:\n\n\nfrom biopandas.mol2 import PandasMol2\n\npmol = PandasMol2().read_mol2('./data/1b5e_1.mol2')\n\n\n\n\nThe \nread_mol2\n method can also load structures from \n.mol2.gz\n files, but if you have a multi-mol2 file, keep in mind that it will only fetch the first molecule in this file. In the section \"\nParsing Multi-MOL2 files\n,\" we will see how we can parse files that contain multiple structures.\n\n\npmol = PandasMol2().read_mol2('./data/40_mol2_files.mol2.gz')\n\n\n\n\nAfter the file was succesfully loaded, we have access to the following basic \nPandasMol2\n attributes:\n\n\nprint('Molecule ID: %s' % pmol.code)\nprint('\\nRaw MOL2 file contents:\\n\\n%s\\n...' % pmol.mol2_text[:500])\n\n\n\n\nMolecule ID: ZINC38611810\n\nRaw MOL2 file contents:\n\n@<TRIPOS>MOLECULE\nZINC38611810\n   65    68     0     0     0\nSMALL\nNO_CHARGES\n\n@<TRIPOS>ATOM\n      1 C1         -1.1786    2.7011   -4.0323 C.3       1 <0>        -0.1537\n      2 C2         -1.2950    1.2442   -3.5798 C.3       1 <0>        -0.1156\n      3 C3         -0.1742    0.4209   -4.2178 C.3       1 <0>        -0.1141\n      4 C4         -0.2887   -1.0141   -3.7721 C.2       1 <0>         0.4504\n      5 O1         -1.1758   -1.3445   -3.0212 O.2       1 <0>        -0.4896\n      6 O2       \n...\n\n\n\nThe most interesting and useful attribute, however, is the \nPandasMol2.df\n DataFrame, which contains the ATOM section of the MOL2 structure. Let's print the first 3 lines from the \nATOM\n coordinate section to see how it looks like:\n\n\npmol.df.head(3)\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \natom_id\n\n      \natom_name\n\n      \nx\n\n      \ny\n\n      \n...\n\n      \natom_type\n\n      \nsubst_id\n\n      \nsubst_name\n\n      \ncharge\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \n1\n\n      \nC1\n\n      \n-1.1786\n\n      \n2.7011\n\n      \n...\n\n      \nC.3\n\n      \n1\n\n      \n<0>\n\n      \n-0.1537\n\n    \n\n    \n\n      \n1\n\n      \n2\n\n      \nC2\n\n      \n-1.2950\n\n      \n1.2442\n\n      \n...\n\n      \nC.3\n\n      \n1\n\n      \n<0>\n\n      \n-0.1156\n\n    \n\n    \n\n      \n2\n\n      \n3\n\n      \nC3\n\n      \n-0.1742\n\n      \n0.4209\n\n      \n...\n\n      \nC.3\n\n      \n1\n\n      \n<0>\n\n      \n-0.1141\n\n    \n\n  \n\n\n\n\n3 rows \u00d7 9 columns\n\n\n\n\n\nThe MOL2 Data Format\n\n\nPandasMol2\n expects the MOL2 file to be in the standard Tripos MOL2 format, and most importantly, that the \"@\nATOM\" section is consistent with the following format convention:\n\n\n\n\nFormat:\n     \natom_id atom_name x y z atom_type [subst_id\n        [subst_name [charge [status_bit]]]]\n\n\n\n\natom_id (integer) = the ID number of the atom at the time the file was created. This is provided for reference only and is not used when the .mol2 file is read into SYBYL.\n\n\natom_name (string) = the name of the atom.\n\n\nx (real) = the x coordinate of the atom.\n\n\ny (real) = the y coordinate of the atom.\n\n\nz (real) = the z coordinate of the atom.\n\n\natom_type (string) = the SYBYL atom type for the atom.\n\n\nsubst_id (integer) = the ID number of the substructure containing the atom.\n\n\nsubst_name (string) = the name of the substructure containing the atom.\n\n\ncharge (real) = the charge associated with the atom.\n\n\nstatus_bit (string) = the internal SYBYL status bits associated with the atom. These should never be set by the user. Valid status bits are DSPMOD, TYPECOL, CAP, BACKBONE, DICT, ESSENTIAL, WATER and DIRECT.\n\n\n\n\n\n\nFor example, the contents of a typical Tripos MOL2 file may look like this:\n\n\n@<TRIPOS>MOLECULE\nDCM Pose 1\n   32    33     0     0     0\nSMALL\nUSER_CHARGES\n@<TRIPOS>ATOM\n      1 C1         18.8934    5.5819   24.1747 C.2       1 <0>       -0.1356 \n      2 C2         18.1301    4.7642   24.8969 C.2       1 <0>       -0.0410 \n      3 C3         18.2645    6.8544   23.7342 C.2       1 <0>        0.4856 \n...\n     31 H11        18.5977    8.5756   22.6932 H         1 <0>        0.4000 \n     32 H12        14.2530    1.0535   27.4278 H         1 <0>        0.4000 \n@<TRIPOS>BOND\n    1     1     2 2\n    2     1     3 1\n    3     2    11 1\n    4     3    10 2\n    5     3    12 1\n...\n   28     8    27 1\n   29     9    28 1\n   30     9    29 1\n   31    12    30 1\n   32    12    31 1\n   33    18    32 1\n\n\n\n\nWorking with MOL2 DataFrames\n\n\nIn the previous sections, we've seen how to load MOL2 structures into DataFrames and how to access them. Once, we have the ATOM section of a MOL2 file in a DataFrame format, we can readily slice and dice the molecular structure and analyze it.\nTo demonstrate some typical use cases, let us load the structure of deoxycytidylate hydroxymethylase (DCM), which is shown in the figure below:\n\n\n\n\nfrom biopandas.mol2 import PandasMol2\n\npmol = PandasMol2()\npmol.read_mol2('./data/1b5e_1.mol2')\npmol.df.tail(10)\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \natom_id\n\n      \natom_name\n\n      \nx\n\n      \ny\n\n      \nz\n\n      \natom_type\n\n      \nsubst_id\n\n      \nsubst_name\n\n      \ncharge\n\n    \n\n  \n\n  \n\n    \n\n      \n22\n\n      \n23\n\n      \nH3\n\n      \n15.8520\n\n      \n2.8983\n\n      \n24.1870\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.0\n\n    \n\n    \n\n      \n23\n\n      \n24\n\n      \nH4\n\n      \n14.3405\n\n      \n3.3601\n\n      \n24.9711\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.0\n\n    \n\n    \n\n      \n24\n\n      \n25\n\n      \nH5\n\n      \n15.3663\n\n      \n0.9351\n\n      \n25.4839\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.0\n\n    \n\n    \n\n      \n25\n\n      \n26\n\n      \nH6\n\n      \n16.6681\n\n      \n1.6130\n\n      \n27.8171\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.0\n\n    \n\n    \n\n      \n26\n\n      \n27\n\n      \nH7\n\n      \n15.3483\n\n      \n4.6961\n\n      \n26.6094\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.0\n\n    \n\n    \n\n      \n27\n\n      \n28\n\n      \nH8\n\n      \n18.8490\n\n      \n1.8078\n\n      \n26.4511\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.0\n\n    \n\n    \n\n      \n28\n\n      \n29\n\n      \nH9\n\n      \n17.8303\n\n      \n1.5497\n\n      \n25.0110\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.0\n\n    \n\n    \n\n      \n29\n\n      \n30\n\n      \nH10\n\n      \n19.9527\n\n      \n7.4708\n\n      \n22.7715\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.4\n\n    \n\n    \n\n      \n30\n\n      \n31\n\n      \nH11\n\n      \n18.5977\n\n      \n8.5756\n\n      \n22.6932\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.4\n\n    \n\n    \n\n      \n31\n\n      \n32\n\n      \nH12\n\n      \n14.2530\n\n      \n1.0535\n\n      \n27.4278\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.4\n\n    \n\n  \n\n\n\n\n\n\n\nFor example, we can select all hydrogen atoms by filtering on the atom type column:\n\n\npmol.df[pmol.df['atom_type'] != 'H'].tail(10)\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \natom_id\n\n      \natom_name\n\n      \nx\n\n      \ny\n\n      \nz\n\n      \natom_type\n\n      \nsubst_id\n\n      \nsubst_name\n\n      \ncharge\n\n    \n\n  \n\n  \n\n    \n\n      \n10\n\n      \n11\n\n      \nN2\n\n      \n16.8196\n\n      \n5.0644\n\n      \n25.2302\n\n      \nN.am\n\n      \n1\n\n      \n<0>\n\n      \n-0.4691\n\n    \n\n    \n\n      \n11\n\n      \n12\n\n      \nN3\n\n      \n19.0194\n\n      \n7.7275\n\n      \n22.9859\n\n      \nN.pl3\n\n      \n1\n\n      \n<0>\n\n      \n-0.8500\n\n    \n\n    \n\n      \n12\n\n      \n13\n\n      \nO1\n\n      \n18.7676\n\n      \n-2.3524\n\n      \n26.1510\n\n      \nO.3\n\n      \n1\n\n      \n<0>\n\n      \n-1.0333\n\n    \n\n    \n\n      \n13\n\n      \n14\n\n      \nO2\n\n      \n20.3972\n\n      \n-0.3812\n\n      \n26.2318\n\n      \nO.3\n\n      \n1\n\n      \n<0>\n\n      \n-1.0333\n\n    \n\n    \n\n      \n14\n\n      \n15\n\n      \nO3\n\n      \n15.0888\n\n      \n6.5824\n\n      \n25.0727\n\n      \nO.2\n\n      \n1\n\n      \n<0>\n\n      \n-0.5700\n\n    \n\n    \n\n      \n15\n\n      \n16\n\n      \nO4\n\n      \n18.9314\n\n      \n-0.7527\n\n      \n24.1606\n\n      \nO.2\n\n      \n1\n\n      \n<0>\n\n      \n-1.0333\n\n    \n\n    \n\n      \n16\n\n      \n17\n\n      \nO5\n\n      \n16.9690\n\n      \n3.4315\n\n      \n26.8994\n\n      \nO.3\n\n      \n1\n\n      \n<0>\n\n      \n-0.5600\n\n    \n\n    \n\n      \n17\n\n      \n18\n\n      \nO6\n\n      \n14.3223\n\n      \n1.8946\n\n      \n26.9702\n\n      \nO.3\n\n      \n1\n\n      \n<0>\n\n      \n-0.6800\n\n    \n\n    \n\n      \n18\n\n      \n19\n\n      \nO7\n\n      \n17.9091\n\n      \n-0.0135\n\n      \n26.3390\n\n      \nO.3\n\n      \n1\n\n      \n<0>\n\n      \n-0.5512\n\n    \n\n    \n\n      \n19\n\n      \n20\n\n      \nP1\n\n      \n19.0969\n\n      \n-0.9440\n\n      \n25.6653\n\n      \nP.3\n\n      \n1\n\n      \n<0>\n\n      \n1.3712\n\n    \n\n  \n\n\n\n\n\n\n\nOr, if we like  to count the number of keto-groups in this molecule, we can do the following:\n\n\nketo = pmol.df[pmol.df['atom_type'] == 'O.2']\nprint('number of keto groups: %d' % keto.shape[0])\nketo\n\n\n\n\nnumber of keto groups: 2\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \natom_id\n\n      \natom_name\n\n      \nx\n\n      \ny\n\n      \n...\n\n      \natom_type\n\n      \nsubst_id\n\n      \nsubst_name\n\n      \ncharge\n\n    \n\n  \n\n  \n\n    \n\n      \n14\n\n      \n15\n\n      \nO3\n\n      \n15.0888\n\n      \n6.5824\n\n      \n...\n\n      \nO.2\n\n      \n1\n\n      \n<0>\n\n      \n-0.5700\n\n    \n\n    \n\n      \n15\n\n      \n16\n\n      \nO4\n\n      \n18.9314\n\n      \n-0.7527\n\n      \n...\n\n      \nO.2\n\n      \n1\n\n      \n<0>\n\n      \n-1.0333\n\n    \n\n  \n\n\n\n\n2 rows \u00d7 9 columns\n\n\n\n\n\nA list of all the allowed atom types that can be found in Tripos MOL2 files is provided below:\n\n\nCode       Definition\nC.3        carbon sp3\nC.2        carbon sp2\nC.1        carbon sp\nC.ar       carbon aromatic\nC.cat      cabocation (C+) used only in a guadinium group\nN.3        nitrogen sp3\nN.2        nitrogen sp2\nN.1        nitrogen sp\nN.ar       nitrogen aromatic\nN.am       nitrogen amide\nN.pl3      nitrogen trigonal planar\nN.4        nitrogen sp3 positively charged\nO.3        oxygen sp3\nO.2        oxygen sp2\nO.co2      oxygen in carboxylate and phosphate groups\nO.spc      oxygen in Single Point Charge (SPC) water model\nO.t3p      oxygen in Transferable Intermolecular Potential (TIP3P) water model\nS.3        sulfur sp3\nS.2        sulfur sp2\nS.O        sulfoxide sulfur\nS.O2       sulfone sulfur\nP.3        phosphorous sp3\nF          fluorine\nH          hydrogen\nH.spc      hydrogen in Single Point Charge (SPC) water model\nH.t3p      hydrogen in Transferable Intermolecular Potential (TIP3P) water model\nLP         lone pair\nDu         dummy atom\nDu.C       dummy carbon\nAny        any atom\nHal        halogen\nHet        heteroatom = N, O, S, P\nHev        heavy atom (non hydrogen)\nLi         lithium\nNa         sodium\nMg         magnesium\nAl         aluminum\nSi         silicon\nK          potassium\nCa         calcium\nCr.thm     chromium (tetrahedral)\nCr.oh      chromium (octahedral)\nMn         manganese\nFe         iron\nCo.oh      cobalt (octahedral)\nCu         copper\n\n\n\nPlotting\n\n\nSince we are using pandas under the hood, which in turns uses matplotlib under the hood, we can produce quick summary plots of our MOL2 structures conveniently. Below are a few examples of how to visualize molecular properties.\n\n\nfrom biopandas.mol2 import PandasMol2\n\npmol = PandasMol2().read_mol2('./data/1b5e_1.mol2')\n\n\n\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom matplotlib import style\nstyle.use('ggplot')\n\n\n\n\nFor instance, let's say we are interested in the counts of the different atom types that can be found in the MOL2 file; we could do the following:\n\n\npmol.df['atom_type'].value_counts().plot(kind='bar')\nplt.xlabel('atom type')\nplt.ylabel('count')\nplt.show()\n\n\n\n\n\n\nIf this is too fine-grained for our needs, we could summarize the different atom types by atomic elements:\n\n\npmol.df['element_type'] = pmol.df['atom_type'].apply(lambda x: x.split('.')[0])\n\npmol.df['element_type'].value_counts().plot(kind='bar')\nplt.xlabel('element type')\nplt.ylabel('count')\nplt.show()\n\n\n\n\n\n\nOne of the coolest features in pandas is the groupby method. Below is an example plotting the average charge of the different atom types with the standard deviation as error bars:\n\n\ngroupby_charge = pmol.df.groupby(['atom_type'])['charge']\ngroupby_charge.mean().plot(kind='bar', yerr=groupby_charge.std())\nplt.ylabel('charge')\nplt.show()\n\n\n\n\n\n\nComputing the Root Mean Square Deviation\n\n\nThe Root-mean-square deviation (RMSD) is simply a measure of the average distance between atoms of 2 structures. This calculation of the Cartesian error follows the equation:\n\n\n$$RMSD(a, b) = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} \\big((a_{ix})^2 + (a_{iy})^2 + (a_{iz})^2 \\big)} \\\\\n= \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} || a_i + b_i||_2^2}$$\n\n\nSo, assuming that the we have the following 2 conformations of a ligand molecule\n\n\n\n\nwe can compute the RMSD as follows:\n\n\nfrom biopandas.mol2 import PandasMol2\n\nl_1 = PandasMol2().read_mol2('./data/1b5e_1.mol2')\nl_2 = PandasMol2().read_mol2('./data/1b5e_2.mol2')\n\nr_heavy = PandasMol2.rmsd(l_1.df, l_2.df)\nr_all  = PandasMol2.rmsd(l_1.df, l_2.df, heavy_only=False)\n\nprint('Heavy-atom RMSD: %.4f Angstrom' % r_heavy)\nprint('All-atom RMSD: %.4f Angstrom' % r_all)\n\n\n\n\nHeavy-atom RMSD: 1.1609 Angstrom\nAll-atom RMSD: 1.5523 Angstrom\n\n\n\n\n\nFiltering Atoms by Distance\n\n\nWe can use the \ndistance\n method to compute the distance between each atom (or a subset of atoms) in our data frame and a three-dimensional reference point. For example, let's assume were are interested in computing the distance between a keto group in the DMC molecule, which we've seen earlier, and other atoms in the same molecule.\n\n\nFirst, let's get the coordinates of all keto-groups in this molecule:\n\n\nfrom biopandas.mol2 import PandasMol2\n\npmol = PandasMol2().read_mol2('./data/1b5e_1.mol2')\n\nketo_coord = pmol.df[pmol.df['atom_type'] == 'O.2'][['x', 'y', 'z']]\nketo_coord\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \nx\n\n      \ny\n\n      \nz\n\n    \n\n  \n\n  \n\n    \n\n      \n14\n\n      \n15.0888\n\n      \n6.5824\n\n      \n25.0727\n\n    \n\n    \n\n      \n15\n\n      \n18.9314\n\n      \n-0.7527\n\n      \n24.1606\n\n    \n\n  \n\n\n\n\n\n\n\nIn the following example, we use \nPandasMol2\n's \ndistance\n method. The \ndistance\n method returns a pandas \nSeries\n object containing the Euclidean distance between an atom and all other atoms in the structure. In the following example, \nketo_coord.values[0]\n refers to the x, y, z coordinates of the first row (i.e., first keto group) in the array above:\n\n\nprint('x, y, z coords:', keto_coord.values[0])\ndistances = pmol.distance(keto_coord.values[0])\n\n\n\n\nx, y, z coords: [ 15.0888   6.5824  25.0727]\n\n\n\nFor our convenience, we can add these \ndistances\n to our MOL2 DataFrame:\n\n\npmol.df['distances'] = distances\npmol.df.head()\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \natom_id\n\n      \natom_name\n\n      \nx\n\n      \ny\n\n      \nz\n\n      \natom_type\n\n      \nsubst_id\n\n      \nsubst_name\n\n      \ncharge\n\n      \ndistances\n\n    \n\n  \n\n  \n\n    \n\n      \n0\n\n      \n1\n\n      \nC1\n\n      \n18.8934\n\n      \n5.5819\n\n      \n24.1747\n\n      \nC.2\n\n      \n1\n\n      \n<0>\n\n      \n-0.1356\n\n      \n4.035144\n\n    \n\n    \n\n      \n1\n\n      \n2\n\n      \nC2\n\n      \n18.1301\n\n      \n4.7642\n\n      \n24.8969\n\n      \nC.2\n\n      \n1\n\n      \n<0>\n\n      \n-0.0410\n\n      \n3.547712\n\n    \n\n    \n\n      \n2\n\n      \n3\n\n      \nC3\n\n      \n18.2645\n\n      \n6.8544\n\n      \n23.7342\n\n      \nC.2\n\n      \n1\n\n      \n<0>\n\n      \n0.4856\n\n      \n3.456969\n\n    \n\n    \n\n      \n3\n\n      \n4\n\n      \nC4\n\n      \n16.2520\n\n      \n6.2866\n\n      \n24.7933\n\n      \nC.2\n\n      \n1\n\n      \n<0>\n\n      \n0.8410\n\n      \n1.232313\n\n    \n\n    \n\n      \n4\n\n      \n5\n\n      \nC5\n\n      \n15.3820\n\n      \n3.0682\n\n      \n25.1622\n\n      \nC.3\n\n      \n1\n\n      \n<0>\n\n      \n0.0000\n\n      \n3.527546\n\n    \n\n  \n\n\n\n\n\n\n\nNow, say we are interested in the Euclidean distance between the two keto groups in the molecule:\n\n\npmol.df[pmol.df['atom_type'] == 'O.2']\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \natom_id\n\n      \natom_name\n\n      \nx\n\n      \ny\n\n      \nz\n\n      \natom_type\n\n      \nsubst_id\n\n      \nsubst_name\n\n      \ncharge\n\n      \ndistances\n\n    \n\n  \n\n  \n\n    \n\n      \n14\n\n      \n15\n\n      \nO3\n\n      \n15.0888\n\n      \n6.5824\n\n      \n25.0727\n\n      \nO.2\n\n      \n1\n\n      \n<0>\n\n      \n-0.5700\n\n      \n0.000000\n\n    \n\n    \n\n      \n15\n\n      \n16\n\n      \nO4\n\n      \n18.9314\n\n      \n-0.7527\n\n      \n24.1606\n\n      \nO.2\n\n      \n1\n\n      \n<0>\n\n      \n-1.0333\n\n      \n8.330738\n\n    \n\n  \n\n\n\n\n\n\n\nIn the example above, the distance between the two keto groups is 8 angstrom.\n\n\n\n\nAnother common task that we can perform using these atomic distances is to select only the neighboring atoms of the keto group (here: atoms within 3 angstrom). The code is as follows:\n\n\nall_within_3A = pmol.df[pmol.df['distances'] <= 3.0]\nall_within_3A.tail()\n\n\n\n\n\n\n\n  \n\n    \n\n      \n\n      \natom_id\n\n      \natom_name\n\n      \nx\n\n      \ny\n\n      \nz\n\n      \natom_type\n\n      \nsubst_id\n\n      \nsubst_name\n\n      \ncharge\n\n      \ndistances\n\n    \n\n  \n\n  \n\n    \n\n      \n7\n\n      \n8\n\n      \nC8\n\n      \n16.0764\n\n      \n4.1199\n\n      \n26.0119\n\n      \nC.3\n\n      \n1\n\n      \n<0>\n\n      \n0.5801\n\n      \n2.814490\n\n    \n\n    \n\n      \n9\n\n      \n10\n\n      \nN1\n\n      \n17.0289\n\n      \n7.1510\n\n      \n24.0411\n\n      \nN.2\n\n      \n1\n\n      \n<0>\n\n      \n-0.6610\n\n      \n2.269690\n\n    \n\n    \n\n      \n10\n\n      \n11\n\n      \nN2\n\n      \n16.8196\n\n      \n5.0644\n\n      \n25.2302\n\n      \nN.am\n\n      \n1\n\n      \n<0>\n\n      \n-0.4691\n\n      \n2.307553\n\n    \n\n    \n\n      \n14\n\n      \n15\n\n      \nO3\n\n      \n15.0888\n\n      \n6.5824\n\n      \n25.0727\n\n      \nO.2\n\n      \n1\n\n      \n<0>\n\n      \n-0.5700\n\n      \n0.000000\n\n    \n\n    \n\n      \n26\n\n      \n27\n\n      \nH7\n\n      \n15.3483\n\n      \n4.6961\n\n      \n26.6094\n\n      \nH\n\n      \n1\n\n      \n<0>\n\n      \n0.0000\n\n      \n2.446817\n\n    \n\n  \n\n\n\n\n\n\n\nParsing Multi-MOL2 files\n\n\nAs mentioned earlier, \nPandasMol2.read_mol2\n method only reads in the first molecule if it is given a multi-MOL2 file. However, if we want to create DataFrames from multiple structures in a MOL2 file, we can use the handy \nsplit_multimol2\n generator.\n\n\nThe \nsplit_multimol2\n generator yields tuples containing the molecule IDs and the MOL2 content as strings in a list -- each line in the MOL2 file is stored as a string in the list.\n\n\nfrom biopandas.mol2 import split_multimol2\n\nmol2_id, mol2_cont = next(split_multimol2('./data/40_mol2_files.mol2'))\n\nprint('Molecule ID:\\n', mol2_id)\nprint('First 10 lines:\\n', mol2_cont[:10])\n\n\n\n\nMolecule ID:\n ZINC38611810\nFirst 10 lines:\n ['@<TRIPOS>MOLECULE\\n', 'ZINC38611810\\n', '   65    68     0     0     0\\n', 'SMALL\\n', 'NO_CHARGES\\n', '\\n', '@<TRIPOS>ATOM\\n', '      1 C1         -1.1786    2.7011   -4.0323 C.3       1 <0>        -0.1537\\n', '      2 C2         -1.2950    1.2442   -3.5798 C.3       1 <0>        -0.1156\\n', '      3 C3         -0.1742    0.4209   -4.2178 C.3       1 <0>        -0.1141\\n']\n\n\n\nWe can now use this generator to loop over all files in a multi-MOL2 file and create PandasMol2 DataFrames. A typical use case would be the filtering of mol2 files by certain properties:\n\n\npdmol = PandasMol2()\n\nwith open('./data/filtered.mol2', 'w') as f:\n    for mol2 in split_multimol2('./data/40_mol2_files.mol2'):\n        pdmol.read_mol2_from_list(mol2_lines=mol2[1], mol2_code=mol2[0])\n\n        # do some analysis\n        keep_molecule = False\n\n        # save molecule if it passes our filter criterion\n        if keep_molecule: \n            # note that the mol2_text contains the original mol2 content\n            f.write(pdmol.mol2_text)",
            "title": "Working with MOL2 Structures in DataFrames"
        },
        {
            "location": "/tutorials/Working_with_MOL2_Structures_in_DataFrames/#working-with-mol2-structures-in-dataframes",
            "text": "The Tripos MOL2 format is a common format for working with small molecules. In this tutorial, we will go over some examples that illustrate how we can use Biopandas' MOL2 DataFrames to analyze molecules conveniently.",
            "title": "Working with MOL2 Structures in DataFrames"
        },
        {
            "location": "/tutorials/Working_with_MOL2_Structures_in_DataFrames/#loading-mol2-files",
            "text": "Using the  read_mol2  method, we can read MOL2 files from standard .mol2 text files:  from biopandas.mol2 import PandasMol2\n\npmol = PandasMol2().read_mol2('./data/1b5e_1.mol2')  The  read_mol2  method can also load structures from  .mol2.gz  files, but if you have a multi-mol2 file, keep in mind that it will only fetch the first molecule in this file. In the section \" Parsing Multi-MOL2 files ,\" we will see how we can parse files that contain multiple structures.  pmol = PandasMol2().read_mol2('./data/40_mol2_files.mol2.gz')  After the file was succesfully loaded, we have access to the following basic  PandasMol2  attributes:  print('Molecule ID: %s' % pmol.code)\nprint('\\nRaw MOL2 file contents:\\n\\n%s\\n...' % pmol.mol2_text[:500])  Molecule ID: ZINC38611810\n\nRaw MOL2 file contents:\n\n@<TRIPOS>MOLECULE\nZINC38611810\n   65    68     0     0     0\nSMALL\nNO_CHARGES\n\n@<TRIPOS>ATOM\n      1 C1         -1.1786    2.7011   -4.0323 C.3       1 <0>        -0.1537\n      2 C2         -1.2950    1.2442   -3.5798 C.3       1 <0>        -0.1156\n      3 C3         -0.1742    0.4209   -4.2178 C.3       1 <0>        -0.1141\n      4 C4         -0.2887   -1.0141   -3.7721 C.2       1 <0>         0.4504\n      5 O1         -1.1758   -1.3445   -3.0212 O.2       1 <0>        -0.4896\n      6 O2       \n...  The most interesting and useful attribute, however, is the  PandasMol2.df  DataFrame, which contains the ATOM section of the MOL2 structure. Let's print the first 3 lines from the  ATOM  coordinate section to see how it looks like:  pmol.df.head(3)   \n   \n     \n       \n       atom_id \n       atom_name \n       x \n       y \n       ... \n       atom_type \n       subst_id \n       subst_name \n       charge \n     \n   \n   \n     \n       0 \n       1 \n       C1 \n       -1.1786 \n       2.7011 \n       ... \n       C.3 \n       1 \n       <0> \n       -0.1537 \n     \n     \n       1 \n       2 \n       C2 \n       -1.2950 \n       1.2442 \n       ... \n       C.3 \n       1 \n       <0> \n       -0.1156 \n     \n     \n       2 \n       3 \n       C3 \n       -0.1742 \n       0.4209 \n       ... \n       C.3 \n       1 \n       <0> \n       -0.1141 \n     \n     3 rows \u00d7 9 columns",
            "title": "Loading MOL2 Files"
        },
        {
            "location": "/tutorials/Working_with_MOL2_Structures_in_DataFrames/#the-mol2-data-format",
            "text": "PandasMol2  expects the MOL2 file to be in the standard Tripos MOL2 format, and most importantly, that the \"@ ATOM\" section is consistent with the following format convention:   Format:\n      atom_id atom_name x y z atom_type [subst_id\n        [subst_name [charge [status_bit]]]]   atom_id (integer) = the ID number of the atom at the time the file was created. This is provided for reference only and is not used when the .mol2 file is read into SYBYL.  atom_name (string) = the name of the atom.  x (real) = the x coordinate of the atom.  y (real) = the y coordinate of the atom.  z (real) = the z coordinate of the atom.  atom_type (string) = the SYBYL atom type for the atom.  subst_id (integer) = the ID number of the substructure containing the atom.  subst_name (string) = the name of the substructure containing the atom.  charge (real) = the charge associated with the atom.  status_bit (string) = the internal SYBYL status bits associated with the atom. These should never be set by the user. Valid status bits are DSPMOD, TYPECOL, CAP, BACKBONE, DICT, ESSENTIAL, WATER and DIRECT.    For example, the contents of a typical Tripos MOL2 file may look like this:  @<TRIPOS>MOLECULE\nDCM Pose 1\n   32    33     0     0     0\nSMALL\nUSER_CHARGES\n@<TRIPOS>ATOM\n      1 C1         18.8934    5.5819   24.1747 C.2       1 <0>       -0.1356 \n      2 C2         18.1301    4.7642   24.8969 C.2       1 <0>       -0.0410 \n      3 C3         18.2645    6.8544   23.7342 C.2       1 <0>        0.4856 \n...\n     31 H11        18.5977    8.5756   22.6932 H         1 <0>        0.4000 \n     32 H12        14.2530    1.0535   27.4278 H         1 <0>        0.4000 \n@<TRIPOS>BOND\n    1     1     2 2\n    2     1     3 1\n    3     2    11 1\n    4     3    10 2\n    5     3    12 1\n...\n   28     8    27 1\n   29     9    28 1\n   30     9    29 1\n   31    12    30 1\n   32    12    31 1\n   33    18    32 1",
            "title": "The MOL2 Data Format"
        },
        {
            "location": "/tutorials/Working_with_MOL2_Structures_in_DataFrames/#working-with-mol2-dataframes",
            "text": "In the previous sections, we've seen how to load MOL2 structures into DataFrames and how to access them. Once, we have the ATOM section of a MOL2 file in a DataFrame format, we can readily slice and dice the molecular structure and analyze it.\nTo demonstrate some typical use cases, let us load the structure of deoxycytidylate hydroxymethylase (DCM), which is shown in the figure below:   from biopandas.mol2 import PandasMol2\n\npmol = PandasMol2()\npmol.read_mol2('./data/1b5e_1.mol2')\npmol.df.tail(10)   \n   \n     \n       \n       atom_id \n       atom_name \n       x \n       y \n       z \n       atom_type \n       subst_id \n       subst_name \n       charge \n     \n   \n   \n     \n       22 \n       23 \n       H3 \n       15.8520 \n       2.8983 \n       24.1870 \n       H \n       1 \n       <0> \n       0.0 \n     \n     \n       23 \n       24 \n       H4 \n       14.3405 \n       3.3601 \n       24.9711 \n       H \n       1 \n       <0> \n       0.0 \n     \n     \n       24 \n       25 \n       H5 \n       15.3663 \n       0.9351 \n       25.4839 \n       H \n       1 \n       <0> \n       0.0 \n     \n     \n       25 \n       26 \n       H6 \n       16.6681 \n       1.6130 \n       27.8171 \n       H \n       1 \n       <0> \n       0.0 \n     \n     \n       26 \n       27 \n       H7 \n       15.3483 \n       4.6961 \n       26.6094 \n       H \n       1 \n       <0> \n       0.0 \n     \n     \n       27 \n       28 \n       H8 \n       18.8490 \n       1.8078 \n       26.4511 \n       H \n       1 \n       <0> \n       0.0 \n     \n     \n       28 \n       29 \n       H9 \n       17.8303 \n       1.5497 \n       25.0110 \n       H \n       1 \n       <0> \n       0.0 \n     \n     \n       29 \n       30 \n       H10 \n       19.9527 \n       7.4708 \n       22.7715 \n       H \n       1 \n       <0> \n       0.4 \n     \n     \n       30 \n       31 \n       H11 \n       18.5977 \n       8.5756 \n       22.6932 \n       H \n       1 \n       <0> \n       0.4 \n     \n     \n       31 \n       32 \n       H12 \n       14.2530 \n       1.0535 \n       27.4278 \n       H \n       1 \n       <0> \n       0.4 \n     \n      For example, we can select all hydrogen atoms by filtering on the atom type column:  pmol.df[pmol.df['atom_type'] != 'H'].tail(10)   \n   \n     \n       \n       atom_id \n       atom_name \n       x \n       y \n       z \n       atom_type \n       subst_id \n       subst_name \n       charge \n     \n   \n   \n     \n       10 \n       11 \n       N2 \n       16.8196 \n       5.0644 \n       25.2302 \n       N.am \n       1 \n       <0> \n       -0.4691 \n     \n     \n       11 \n       12 \n       N3 \n       19.0194 \n       7.7275 \n       22.9859 \n       N.pl3 \n       1 \n       <0> \n       -0.8500 \n     \n     \n       12 \n       13 \n       O1 \n       18.7676 \n       -2.3524 \n       26.1510 \n       O.3 \n       1 \n       <0> \n       -1.0333 \n     \n     \n       13 \n       14 \n       O2 \n       20.3972 \n       -0.3812 \n       26.2318 \n       O.3 \n       1 \n       <0> \n       -1.0333 \n     \n     \n       14 \n       15 \n       O3 \n       15.0888 \n       6.5824 \n       25.0727 \n       O.2 \n       1 \n       <0> \n       -0.5700 \n     \n     \n       15 \n       16 \n       O4 \n       18.9314 \n       -0.7527 \n       24.1606 \n       O.2 \n       1 \n       <0> \n       -1.0333 \n     \n     \n       16 \n       17 \n       O5 \n       16.9690 \n       3.4315 \n       26.8994 \n       O.3 \n       1 \n       <0> \n       -0.5600 \n     \n     \n       17 \n       18 \n       O6 \n       14.3223 \n       1.8946 \n       26.9702 \n       O.3 \n       1 \n       <0> \n       -0.6800 \n     \n     \n       18 \n       19 \n       O7 \n       17.9091 \n       -0.0135 \n       26.3390 \n       O.3 \n       1 \n       <0> \n       -0.5512 \n     \n     \n       19 \n       20 \n       P1 \n       19.0969 \n       -0.9440 \n       25.6653 \n       P.3 \n       1 \n       <0> \n       1.3712 \n     \n      Or, if we like  to count the number of keto-groups in this molecule, we can do the following:  keto = pmol.df[pmol.df['atom_type'] == 'O.2']\nprint('number of keto groups: %d' % keto.shape[0])\nketo  number of keto groups: 2   \n   \n     \n       \n       atom_id \n       atom_name \n       x \n       y \n       ... \n       atom_type \n       subst_id \n       subst_name \n       charge \n     \n   \n   \n     \n       14 \n       15 \n       O3 \n       15.0888 \n       6.5824 \n       ... \n       O.2 \n       1 \n       <0> \n       -0.5700 \n     \n     \n       15 \n       16 \n       O4 \n       18.9314 \n       -0.7527 \n       ... \n       O.2 \n       1 \n       <0> \n       -1.0333 \n     \n     2 rows \u00d7 9 columns   A list of all the allowed atom types that can be found in Tripos MOL2 files is provided below:  Code       Definition\nC.3        carbon sp3\nC.2        carbon sp2\nC.1        carbon sp\nC.ar       carbon aromatic\nC.cat      cabocation (C+) used only in a guadinium group\nN.3        nitrogen sp3\nN.2        nitrogen sp2\nN.1        nitrogen sp\nN.ar       nitrogen aromatic\nN.am       nitrogen amide\nN.pl3      nitrogen trigonal planar\nN.4        nitrogen sp3 positively charged\nO.3        oxygen sp3\nO.2        oxygen sp2\nO.co2      oxygen in carboxylate and phosphate groups\nO.spc      oxygen in Single Point Charge (SPC) water model\nO.t3p      oxygen in Transferable Intermolecular Potential (TIP3P) water model\nS.3        sulfur sp3\nS.2        sulfur sp2\nS.O        sulfoxide sulfur\nS.O2       sulfone sulfur\nP.3        phosphorous sp3\nF          fluorine\nH          hydrogen\nH.spc      hydrogen in Single Point Charge (SPC) water model\nH.t3p      hydrogen in Transferable Intermolecular Potential (TIP3P) water model\nLP         lone pair\nDu         dummy atom\nDu.C       dummy carbon\nAny        any atom\nHal        halogen\nHet        heteroatom = N, O, S, P\nHev        heavy atom (non hydrogen)\nLi         lithium\nNa         sodium\nMg         magnesium\nAl         aluminum\nSi         silicon\nK          potassium\nCa         calcium\nCr.thm     chromium (tetrahedral)\nCr.oh      chromium (octahedral)\nMn         manganese\nFe         iron\nCo.oh      cobalt (octahedral)\nCu         copper",
            "title": "Working with MOL2 DataFrames"
        },
        {
            "location": "/tutorials/Working_with_MOL2_Structures_in_DataFrames/#plotting",
            "text": "Since we are using pandas under the hood, which in turns uses matplotlib under the hood, we can produce quick summary plots of our MOL2 structures conveniently. Below are a few examples of how to visualize molecular properties.  from biopandas.mol2 import PandasMol2\n\npmol = PandasMol2().read_mol2('./data/1b5e_1.mol2')  %matplotlib inline\nimport matplotlib.pyplot as plt\nfrom matplotlib import style\nstyle.use('ggplot')  For instance, let's say we are interested in the counts of the different atom types that can be found in the MOL2 file; we could do the following:  pmol.df['atom_type'].value_counts().plot(kind='bar')\nplt.xlabel('atom type')\nplt.ylabel('count')\nplt.show()   If this is too fine-grained for our needs, we could summarize the different atom types by atomic elements:  pmol.df['element_type'] = pmol.df['atom_type'].apply(lambda x: x.split('.')[0])\n\npmol.df['element_type'].value_counts().plot(kind='bar')\nplt.xlabel('element type')\nplt.ylabel('count')\nplt.show()   One of the coolest features in pandas is the groupby method. Below is an example plotting the average charge of the different atom types with the standard deviation as error bars:  groupby_charge = pmol.df.groupby(['atom_type'])['charge']\ngroupby_charge.mean().plot(kind='bar', yerr=groupby_charge.std())\nplt.ylabel('charge')\nplt.show()",
            "title": "Plotting"
        },
        {
            "location": "/tutorials/Working_with_MOL2_Structures_in_DataFrames/#computing-the-root-mean-square-deviation",
            "text": "The Root-mean-square deviation (RMSD) is simply a measure of the average distance between atoms of 2 structures. This calculation of the Cartesian error follows the equation:  $$RMSD(a, b) = \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} \\big((a_{ix})^2 + (a_{iy})^2 + (a_{iz})^2 \\big)} \\\\\n= \\sqrt{\\frac{1}{n} \\sum^{n}_{i=1} || a_i + b_i||_2^2}$$  So, assuming that the we have the following 2 conformations of a ligand molecule   we can compute the RMSD as follows:  from biopandas.mol2 import PandasMol2\n\nl_1 = PandasMol2().read_mol2('./data/1b5e_1.mol2')\nl_2 = PandasMol2().read_mol2('./data/1b5e_2.mol2')\n\nr_heavy = PandasMol2.rmsd(l_1.df, l_2.df)\nr_all  = PandasMol2.rmsd(l_1.df, l_2.df, heavy_only=False)\n\nprint('Heavy-atom RMSD: %.4f Angstrom' % r_heavy)\nprint('All-atom RMSD: %.4f Angstrom' % r_all)  Heavy-atom RMSD: 1.1609 Angstrom\nAll-atom RMSD: 1.5523 Angstrom",
            "title": "Computing the Root Mean Square Deviation"
        },
        {
            "location": "/tutorials/Working_with_MOL2_Structures_in_DataFrames/#filtering-atoms-by-distance",
            "text": "We can use the  distance  method to compute the distance between each atom (or a subset of atoms) in our data frame and a three-dimensional reference point. For example, let's assume were are interested in computing the distance between a keto group in the DMC molecule, which we've seen earlier, and other atoms in the same molecule.  First, let's get the coordinates of all keto-groups in this molecule:  from biopandas.mol2 import PandasMol2\n\npmol = PandasMol2().read_mol2('./data/1b5e_1.mol2')\n\nketo_coord = pmol.df[pmol.df['atom_type'] == 'O.2'][['x', 'y', 'z']]\nketo_coord   \n   \n     \n       \n       x \n       y \n       z \n     \n   \n   \n     \n       14 \n       15.0888 \n       6.5824 \n       25.0727 \n     \n     \n       15 \n       18.9314 \n       -0.7527 \n       24.1606 \n     \n      In the following example, we use  PandasMol2 's  distance  method. The  distance  method returns a pandas  Series  object containing the Euclidean distance between an atom and all other atoms in the structure. In the following example,  keto_coord.values[0]  refers to the x, y, z coordinates of the first row (i.e., first keto group) in the array above:  print('x, y, z coords:', keto_coord.values[0])\ndistances = pmol.distance(keto_coord.values[0])  x, y, z coords: [ 15.0888   6.5824  25.0727]  For our convenience, we can add these  distances  to our MOL2 DataFrame:  pmol.df['distances'] = distances\npmol.df.head()   \n   \n     \n       \n       atom_id \n       atom_name \n       x \n       y \n       z \n       atom_type \n       subst_id \n       subst_name \n       charge \n       distances \n     \n   \n   \n     \n       0 \n       1 \n       C1 \n       18.8934 \n       5.5819 \n       24.1747 \n       C.2 \n       1 \n       <0> \n       -0.1356 \n       4.035144 \n     \n     \n       1 \n       2 \n       C2 \n       18.1301 \n       4.7642 \n       24.8969 \n       C.2 \n       1 \n       <0> \n       -0.0410 \n       3.547712 \n     \n     \n       2 \n       3 \n       C3 \n       18.2645 \n       6.8544 \n       23.7342 \n       C.2 \n       1 \n       <0> \n       0.4856 \n       3.456969 \n     \n     \n       3 \n       4 \n       C4 \n       16.2520 \n       6.2866 \n       24.7933 \n       C.2 \n       1 \n       <0> \n       0.8410 \n       1.232313 \n     \n     \n       4 \n       5 \n       C5 \n       15.3820 \n       3.0682 \n       25.1622 \n       C.3 \n       1 \n       <0> \n       0.0000 \n       3.527546 \n     \n      Now, say we are interested in the Euclidean distance between the two keto groups in the molecule:  pmol.df[pmol.df['atom_type'] == 'O.2']   \n   \n     \n       \n       atom_id \n       atom_name \n       x \n       y \n       z \n       atom_type \n       subst_id \n       subst_name \n       charge \n       distances \n     \n   \n   \n     \n       14 \n       15 \n       O3 \n       15.0888 \n       6.5824 \n       25.0727 \n       O.2 \n       1 \n       <0> \n       -0.5700 \n       0.000000 \n     \n     \n       15 \n       16 \n       O4 \n       18.9314 \n       -0.7527 \n       24.1606 \n       O.2 \n       1 \n       <0> \n       -1.0333 \n       8.330738 \n     \n      In the example above, the distance between the two keto groups is 8 angstrom.   Another common task that we can perform using these atomic distances is to select only the neighboring atoms of the keto group (here: atoms within 3 angstrom). The code is as follows:  all_within_3A = pmol.df[pmol.df['distances'] <= 3.0]\nall_within_3A.tail()   \n   \n     \n       \n       atom_id \n       atom_name \n       x \n       y \n       z \n       atom_type \n       subst_id \n       subst_name \n       charge \n       distances \n     \n   \n   \n     \n       7 \n       8 \n       C8 \n       16.0764 \n       4.1199 \n       26.0119 \n       C.3 \n       1 \n       <0> \n       0.5801 \n       2.814490 \n     \n     \n       9 \n       10 \n       N1 \n       17.0289 \n       7.1510 \n       24.0411 \n       N.2 \n       1 \n       <0> \n       -0.6610 \n       2.269690 \n     \n     \n       10 \n       11 \n       N2 \n       16.8196 \n       5.0644 \n       25.2302 \n       N.am \n       1 \n       <0> \n       -0.4691 \n       2.307553 \n     \n     \n       14 \n       15 \n       O3 \n       15.0888 \n       6.5824 \n       25.0727 \n       O.2 \n       1 \n       <0> \n       -0.5700 \n       0.000000 \n     \n     \n       26 \n       27 \n       H7 \n       15.3483 \n       4.6961 \n       26.6094 \n       H \n       1 \n       <0> \n       0.0000 \n       2.446817",
            "title": "Filtering Atoms by Distance"
        },
        {
            "location": "/tutorials/Working_with_MOL2_Structures_in_DataFrames/#parsing-multi-mol2-files",
            "text": "As mentioned earlier,  PandasMol2.read_mol2  method only reads in the first molecule if it is given a multi-MOL2 file. However, if we want to create DataFrames from multiple structures in a MOL2 file, we can use the handy  split_multimol2  generator.  The  split_multimol2  generator yields tuples containing the molecule IDs and the MOL2 content as strings in a list -- each line in the MOL2 file is stored as a string in the list.  from biopandas.mol2 import split_multimol2\n\nmol2_id, mol2_cont = next(split_multimol2('./data/40_mol2_files.mol2'))\n\nprint('Molecule ID:\\n', mol2_id)\nprint('First 10 lines:\\n', mol2_cont[:10])  Molecule ID:\n ZINC38611810\nFirst 10 lines:\n ['@<TRIPOS>MOLECULE\\n', 'ZINC38611810\\n', '   65    68     0     0     0\\n', 'SMALL\\n', 'NO_CHARGES\\n', '\\n', '@<TRIPOS>ATOM\\n', '      1 C1         -1.1786    2.7011   -4.0323 C.3       1 <0>        -0.1537\\n', '      2 C2         -1.2950    1.2442   -3.5798 C.3       1 <0>        -0.1156\\n', '      3 C3         -0.1742    0.4209   -4.2178 C.3       1 <0>        -0.1141\\n']  We can now use this generator to loop over all files in a multi-MOL2 file and create PandasMol2 DataFrames. A typical use case would be the filtering of mol2 files by certain properties:  pdmol = PandasMol2()\n\nwith open('./data/filtered.mol2', 'w') as f:\n    for mol2 in split_multimol2('./data/40_mol2_files.mol2'):\n        pdmol.read_mol2_from_list(mol2_lines=mol2[1], mol2_code=mol2[0])\n\n        # do some analysis\n        keep_molecule = False\n\n        # save molecule if it passes our filter criterion\n        if keep_molecule: \n            # note that the mol2_text contains the original mol2 content\n            f.write(pdmol.mol2_text)",
            "title": "Parsing Multi-MOL2 files"
        },
        {
            "location": "/api_subpackages/biopandas.pdb/",
            "text": "biopandas version: 0.2.0\n\n\nPandasPdb\n\n\nPandasPdb()\n\n\nObject for working with Protein Databank structure files.\n\n\nAttributes\n\n\n\n\n\n\ndf\n : dict\n\n\nDictionary storing pandas DataFrames for PDB record sections.\nThe dictionary keys are {'ATOM', 'HETATM', 'ANISOU', 'OTHERS'}\nwhere 'OTHERS' contains all entries that are not parsed as\n'ATOM', 'HETATM', or 'ANISOU'\n\n\n\n\n\n\npdb_text\n : str\n\n\nPDB file contents in raw text format\n\n\n\n\n\n\nheader\n : str\n\n\nPDB file description\n\n\n\n\n\n\ncode\n : str\n\n\nPDB code\n\n\n\n\n\n\nMethods\n\n\n\n\n\namino3to1(record='ATOM', residue_col='residue_name', fillna='?')\n\n\nCreates 1-letter amino acid codes from DataFrame\n\n\nNon-canonical amino-acids are converted as follows:\nASH (protonated ASP) => D\nCYX (disulfide-bonded CYS) => C\nGLH (protonated GLU) => E\nHID/HIE/HIP (different protonation states of HIS) = H\nHYP (hydroxyproline) => P\nMSE (selenomethionine) => M\n\n\n\nParameters\n\n\n\n\n\n\nrecord\n : str (default: 'ATOM')\n\n\nSpecfies the record DataFrame\n\n\n\n\n\n\nresidue_col\n : str (default: 'residue_name')\n\n\nColumn in \nrecord\n DataFrame to look for 3-letter amino acid\ncodes for the conversion\n\n\n\n\n\n\nfillna\n : str (default: '?')\n\n\nPlaceholder string to use for unknown amino acids\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\npandas.Series\n : Pandas Series object containing the 1-letter amino\n\n\nacid codes after conversion\n\n\n\n\n\n\n\n\n\ndistance(xyz=(0.0, 0.0, 0.0), record='ATOM')\n\n\nComputes Euclidean distance between atoms and a 3D point.\n\n\nParameters\n\n\n\n\n\n\nxyz\n : tuple (0.00, 0.00, 0.00)\n\n\nX, Y, and Z coordinate of the reference center for the distance\ncomputation\n\n\n\n\n\n\nrecord\n : str (default: 'ATOM')\n\n\nSpecfies the record DataFrame\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\npandas.Series\n : Pandas Series object containing the Euclidean\n\n\ndistance between the atoms in the record section and \nxyz\n.\n\n\n\n\n\n\n\n\n\nfetch_pdb(pdb_code)\n\n\nFetches PDB file contents from the Protein Databank at rcsb.org.\n\n\nParameters\n\n\n\n\n\n\npdb_code\n : str\n\n\nA 4-letter PDB code, e.g., \"3eiy\"\n\n\n\n\n\n\nReturns\n\n\nself\n\n\n\n\n\nget(s, df=None, invert=False)\n\n\nFilter PDB DataFrames by properties\n\n\nParameters\n\n\n\n\n\n\ns\n : str  in {'main chain', 'hydrogen', 'c-alpha', 'heavy'}\n\n\nString to specify which entries to return\n\n\n\n\n\n\ndf\n : pandas.DataFrame, default: None\n\n\nOptional DataFrame to perform the filter operation on.\nIf df=None, filters on self.df['ATOM']\n\n\n\n\n\n\ninvert\n : bool, default: True\n\n\nInverts the search query. For example if s='hydrogen' and\ninvert=True, all but hydrogen entries are returned\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\ndf\n : pandas.DataFrame\n\n\nReturns a DataFrame view on the filtered entries.\n\n\n\n\n\n\n\n\n\nimpute_element(sections=('ATOM', 'HETATM'), inplace=False)\n\n\nImpute element_symbol from atom_name section.\n\n\nParameters\n\n\n\n\n\n\nsections\n : iterable (default: ('ATOM', 'HETATM'))\n\n\nCoordinate sections for which the element symbols should be\nimputed.\n\n\n\n\n\n\ninplace\n : bool (default: False)\n\n\nPerforms the operation in-place if True and returns a copy of the\nPDB DataFrame otherwise.\n\n\n\n\n\n\nReturns\n\n\nDataFrame\n\n\n\n\n\nread_pdb(path)\n\n\nRead PDB files (unzipped or gzipped) from local drive\n\n\nAttributes\n\n\n\n\n\n\npath\n : str\n\n\nPath to the PDB file in .pdb format or gzipped format (.pdb.gz)\n\n\n\n\n\n\nReturns\n\n\nself\n\n\n\n\n\nrmsd(df1, df2, s=None, invert=False)\n\n\nCompute the Root Mean Square Deviation between molecules.\n\n\nParameters\n\n\n\n\n\n\ndf1\n : pandas.DataFrame\n\n\nDataFrame with HETATM, ATOM, and/or ANISOU entries\n\n\n\n\n\n\ndf2\n : pandas.DataFrame\n\n\nSecond DataFrame for RMSD computation against df1. Must have the\nsame number of entries as df1\n\n\n\n\n\n\ns\n : {'main chain', 'hydrogen', 'c-alpha', 'heavy', 'carbon'} or None,\n\n\ndefault: None\nString to specify which entries to consider. If None, considers\nall atoms for comparison.\n\n\n\n\n\n\ninvert\n : bool, default: False\n\n\nInverts the string query if true. For example, the setting\n\ns='hydrogen', invert=True\n computes the RMSD based on all\nbut hydrogen atoms.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\nrmsd\n : float\n\n\nRoot Mean Square Deviation between df1 and df2\n\n\n\n\n\n\n\n\n\nto_pdb(path, records=None, gz=False, append_newline=True)\n\n\nWrite record DataFrames to a PDB file or gzipped PDB file.\n\n\nParameters\n\n\n\n\n\n\npath\n : str\n\n\nA valid output path for the pdb file\n\n\n\n\n\n\nrecords\n : iterable, default: None\n\n\nA list of PDB record sections in\n{'ATOM', 'HETATM', 'ANISOU', 'OTHERS'} that are to be written.\nWrites all lines to PDB if records=None\n\n\n\n\n\n\ngz\n : bool, default: False\n\n\nWrites a gzipped PDB file if True\n\n\n\n\n\n\nappend_newline\n : bool, default: True\n\n\nAppends a new line at the end of the PDB file if True\n\n\n\n\n\n\nProperties\n\n\n\n\n\ndf\n\n\nAcccess dictionary of pandas DataFrames for PDB record sections.",
            "title": "Biopandas.pdb"
        },
        {
            "location": "/api_subpackages/biopandas.pdb/#pandaspdb",
            "text": "PandasPdb()  Object for working with Protein Databank structure files.  Attributes    df  : dict  Dictionary storing pandas DataFrames for PDB record sections.\nThe dictionary keys are {'ATOM', 'HETATM', 'ANISOU', 'OTHERS'}\nwhere 'OTHERS' contains all entries that are not parsed as\n'ATOM', 'HETATM', or 'ANISOU'    pdb_text  : str  PDB file contents in raw text format    header  : str  PDB file description    code  : str  PDB code",
            "title": "PandasPdb"
        },
        {
            "location": "/api_subpackages/biopandas.pdb/#methods",
            "text": "amino3to1(record='ATOM', residue_col='residue_name', fillna='?')  Creates 1-letter amino acid codes from DataFrame  Non-canonical amino-acids are converted as follows:\nASH (protonated ASP) => D\nCYX (disulfide-bonded CYS) => C\nGLH (protonated GLU) => E\nHID/HIE/HIP (different protonation states of HIS) = H\nHYP (hydroxyproline) => P\nMSE (selenomethionine) => M  Parameters    record  : str (default: 'ATOM')  Specfies the record DataFrame    residue_col  : str (default: 'residue_name')  Column in  record  DataFrame to look for 3-letter amino acid\ncodes for the conversion    fillna  : str (default: '?')  Placeholder string to use for unknown amino acids    Returns    pandas.Series  : Pandas Series object containing the 1-letter amino  acid codes after conversion     distance(xyz=(0.0, 0.0, 0.0), record='ATOM')  Computes Euclidean distance between atoms and a 3D point.  Parameters    xyz  : tuple (0.00, 0.00, 0.00)  X, Y, and Z coordinate of the reference center for the distance\ncomputation    record  : str (default: 'ATOM')  Specfies the record DataFrame    Returns    pandas.Series  : Pandas Series object containing the Euclidean  distance between the atoms in the record section and  xyz .     fetch_pdb(pdb_code)  Fetches PDB file contents from the Protein Databank at rcsb.org.  Parameters    pdb_code  : str  A 4-letter PDB code, e.g., \"3eiy\"    Returns  self   get(s, df=None, invert=False)  Filter PDB DataFrames by properties  Parameters    s  : str  in {'main chain', 'hydrogen', 'c-alpha', 'heavy'}  String to specify which entries to return    df  : pandas.DataFrame, default: None  Optional DataFrame to perform the filter operation on.\nIf df=None, filters on self.df['ATOM']    invert  : bool, default: True  Inverts the search query. For example if s='hydrogen' and\ninvert=True, all but hydrogen entries are returned    Returns    df  : pandas.DataFrame  Returns a DataFrame view on the filtered entries.     impute_element(sections=('ATOM', 'HETATM'), inplace=False)  Impute element_symbol from atom_name section.  Parameters    sections  : iterable (default: ('ATOM', 'HETATM'))  Coordinate sections for which the element symbols should be\nimputed.    inplace  : bool (default: False)  Performs the operation in-place if True and returns a copy of the\nPDB DataFrame otherwise.    Returns  DataFrame   read_pdb(path)  Read PDB files (unzipped or gzipped) from local drive  Attributes    path  : str  Path to the PDB file in .pdb format or gzipped format (.pdb.gz)    Returns  self   rmsd(df1, df2, s=None, invert=False)  Compute the Root Mean Square Deviation between molecules.  Parameters    df1  : pandas.DataFrame  DataFrame with HETATM, ATOM, and/or ANISOU entries    df2  : pandas.DataFrame  Second DataFrame for RMSD computation against df1. Must have the\nsame number of entries as df1    s  : {'main chain', 'hydrogen', 'c-alpha', 'heavy', 'carbon'} or None,  default: None\nString to specify which entries to consider. If None, considers\nall atoms for comparison.    invert  : bool, default: False  Inverts the string query if true. For example, the setting s='hydrogen', invert=True  computes the RMSD based on all\nbut hydrogen atoms.    Returns    rmsd  : float  Root Mean Square Deviation between df1 and df2     to_pdb(path, records=None, gz=False, append_newline=True)  Write record DataFrames to a PDB file or gzipped PDB file.  Parameters    path  : str  A valid output path for the pdb file    records  : iterable, default: None  A list of PDB record sections in\n{'ATOM', 'HETATM', 'ANISOU', 'OTHERS'} that are to be written.\nWrites all lines to PDB if records=None    gz  : bool, default: False  Writes a gzipped PDB file if True    append_newline  : bool, default: True  Appends a new line at the end of the PDB file if True",
            "title": "Methods"
        },
        {
            "location": "/api_subpackages/biopandas.pdb/#properties",
            "text": "df  Acccess dictionary of pandas DataFrames for PDB record sections.",
            "title": "Properties"
        },
        {
            "location": "/api_subpackages/biopandas.mol2/",
            "text": "biopandas version: 0.2.0\n\n\nPandasMol2\n\n\nPandasMol2()\n\n\nObject for working with Tripos Mol2 structure files.\n\n\nAttributes\n\n\n\n\n\n\ndf\n : pandas.DataFrame\n\n\nDataFrame of a Mol2's ATOM section\n\n\n\n\n\n\nmol2_text\n : str\n\n\nMol2 file contents in string format\n\n\n\n\n\n\ncode\n : str\n\n\nID, code, or name of the molecule stored\n\n\n\n\n\n\nMethods\n\n\n\n\n\ndistance(xyz=(0.0, 0.0, 0.0))\n\n\nComputes Euclidean distance between atoms and a 3D point.\n\n\nParameters\n\n\n\n\n\n\nxyz\n : tuple (0.00, 0.00, 0.00)\n\n\nX, Y, and Z coordinate of the reference center for the distance\ncomputation\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\npandas.Series\n : Pandas Series object containing the Euclidean\n\n\ndistance between the atoms in the atom section and \nxyz\n.\n\n\n\n\n\n\n\n\n\nread_mol2(path, columns=None)\n\n\nReads Mol2 files (unzipped or gzipped) from local drive\n\n\nNote that if your mol2 file contains more than one molecule,\nonly the first molecule is loaded into the DataFrame\n\n\n\nAttributes\n\n\n\n\n\n\npath\n : str\n\n\nPath to the Mol2 file in .mol2 format or gzipped format (.mol2.gz)\n\n\n\n\n\n\ncolumns\n : dict or None (default: None)\n\n\nIf None, this methods expects a 9-column ATOM section that contains\nthe following columns:\n\n\n{0:('atom_id', int), 1:('atom_name', str),\n2:('x', float), 3:('y', float), 4:('z', float),\n5:('atom_type', str), 6:('subst_id', int),\n7:('subst_name', str), 8:('charge', float)}\n\n\nIf your Mol2 files are formatted differently, you can provide your\nown column_mapping dictionary in a format similar to the one above.\nHowever, note that not all assert_raise_message methods\nmay be supported then.\n\n\n\n\n\n\nReturns\n\n\nself\n\n\n\n\n\nread_mol2_from_list(mol2_lines, mol2_code, columns=None)\n\n\nReads Mol2 file from a list into DataFrames\n\n\nAttributes\n\n\n\n\n\n\nmol2_lines\n : list\n\n\nA list of lines containing the mol2 file contents. For example,\n['@\nMOLECULE\\n',\n'ZINC38611810\\n',\n'   65    68     0     0     0\\n',\n'SMALL\\n',\n'NO_CHARGES\\n',\n'\\n',\n'@\nATOM\\n',\n'      1 C1  -1.1786  2.7011  -4.0323 C.3  1 <0>   -0.1537\\n',\n'      2 C2  -1.2950  1.2442  -3.5798 C.3  1 <0>   -0.1156\\n',\n...]\n\n\n\n\n\n\nmol2_code\n : str or None\n\n\nName or ID of the molecule.\n\n\n\n\n\n\ncolumns\n : dict or None (default: None)\n\n\nIf None, this methods expects a 9-column ATOM section that contains\nthe following columns:\n{0:('atom_id', int), 1:('atom_name', str),\n2:('x', float), 3:('y', float), 4:('z', float),\n5:('atom_type', str), 6:('subst_id', int),\n7:('subst_name', str), 8:('charge', float)}\nIf your Mol2 files are formatted differently, you can provide your\nown column_mapping dictionary in a format similar to the one above.\nHowever, note that not all assert_raise_message methods may be\nsupported then.\n\n\n\n\n\n\nReturns\n\n\nself\n\n\n\n\n\nrmsd(df1, df2, heavy_only=True)\n\n\nCompute the Root Mean Square Deviation between molecules\n\n\nParameters\n\n\n\n\n\n\ndf1\n : pandas.DataFrame\n\n\nDataFrame with HETATM, ATOM, and/or ANISOU entries\n\n\n\n\n\n\ndf2\n : pandas.DataFrame\n\n\nSecond DataFrame for RMSD computation against df1. Must have the\nsame number of entries as df1\n\n\n\n\n\n\nheavy_only\n : bool (default: True)\n\n\nWhich atoms to compare to compute the RMSD. If \nTrue\n (default),\ncomputes the RMSD between non-hydrogen atoms only.\n\n\n\n\n\n\nReturns\n\n\n\n\n\n\nrmsd\n : float\n\n\nRoot Mean Square Deviation between df1 and df2\n\n\n\n\n\n\nProperties\n\n\n\n\n\ndf\n\n\nAcccesses the pandas DataFrame\n\n\nsplit_multimol2\n\n\nsplit_multimol2(mol2_path)\n\n\nSplits a multi-mol2 file into individual Mol2 file contents.\n\n\nParameters\n\n\n\n\n\n\nmol2_path\n : str\n\n\nPath to the multi-mol2 file. Parses gzip files if the filepath\nends on .gz.\n\n\n\n\n\n\nReturns\n\n\nA generator object for lists for every extracted mol2-file. Lists contain\n    the molecule ID and the mol2 file contents.\n    e.g., ['ID1234', ['@\nMOLECULE\\n', '...']]. Note that bytestrings\n    are returned (for reasons of efficieny) if the Mol2 content is read\n    from a gzip (.gz) file.",
            "title": "Biopandas.mol2"
        },
        {
            "location": "/api_subpackages/biopandas.mol2/#pandasmol2",
            "text": "PandasMol2()  Object for working with Tripos Mol2 structure files.  Attributes    df  : pandas.DataFrame  DataFrame of a Mol2's ATOM section    mol2_text  : str  Mol2 file contents in string format    code  : str  ID, code, or name of the molecule stored",
            "title": "PandasMol2"
        },
        {
            "location": "/api_subpackages/biopandas.mol2/#methods",
            "text": "distance(xyz=(0.0, 0.0, 0.0))  Computes Euclidean distance between atoms and a 3D point.  Parameters    xyz  : tuple (0.00, 0.00, 0.00)  X, Y, and Z coordinate of the reference center for the distance\ncomputation    Returns    pandas.Series  : Pandas Series object containing the Euclidean  distance between the atoms in the atom section and  xyz .     read_mol2(path, columns=None)  Reads Mol2 files (unzipped or gzipped) from local drive  Note that if your mol2 file contains more than one molecule,\nonly the first molecule is loaded into the DataFrame  Attributes    path  : str  Path to the Mol2 file in .mol2 format or gzipped format (.mol2.gz)    columns  : dict or None (default: None)  If None, this methods expects a 9-column ATOM section that contains\nthe following columns:  {0:('atom_id', int), 1:('atom_name', str),\n2:('x', float), 3:('y', float), 4:('z', float),\n5:('atom_type', str), 6:('subst_id', int),\n7:('subst_name', str), 8:('charge', float)}  If your Mol2 files are formatted differently, you can provide your\nown column_mapping dictionary in a format similar to the one above.\nHowever, note that not all assert_raise_message methods\nmay be supported then.    Returns  self   read_mol2_from_list(mol2_lines, mol2_code, columns=None)  Reads Mol2 file from a list into DataFrames  Attributes    mol2_lines  : list  A list of lines containing the mol2 file contents. For example,\n['@ MOLECULE\\n',\n'ZINC38611810\\n',\n'   65    68     0     0     0\\n',\n'SMALL\\n',\n'NO_CHARGES\\n',\n'\\n',\n'@ ATOM\\n',\n'      1 C1  -1.1786  2.7011  -4.0323 C.3  1 <0>   -0.1537\\n',\n'      2 C2  -1.2950  1.2442  -3.5798 C.3  1 <0>   -0.1156\\n',\n...]    mol2_code  : str or None  Name or ID of the molecule.    columns  : dict or None (default: None)  If None, this methods expects a 9-column ATOM section that contains\nthe following columns:\n{0:('atom_id', int), 1:('atom_name', str),\n2:('x', float), 3:('y', float), 4:('z', float),\n5:('atom_type', str), 6:('subst_id', int),\n7:('subst_name', str), 8:('charge', float)}\nIf your Mol2 files are formatted differently, you can provide your\nown column_mapping dictionary in a format similar to the one above.\nHowever, note that not all assert_raise_message methods may be\nsupported then.    Returns  self   rmsd(df1, df2, heavy_only=True)  Compute the Root Mean Square Deviation between molecules  Parameters    df1  : pandas.DataFrame  DataFrame with HETATM, ATOM, and/or ANISOU entries    df2  : pandas.DataFrame  Second DataFrame for RMSD computation against df1. Must have the\nsame number of entries as df1    heavy_only  : bool (default: True)  Which atoms to compare to compute the RMSD. If  True  (default),\ncomputes the RMSD between non-hydrogen atoms only.    Returns    rmsd  : float  Root Mean Square Deviation between df1 and df2",
            "title": "Methods"
        },
        {
            "location": "/api_subpackages/biopandas.mol2/#properties",
            "text": "df  Acccesses the pandas DataFrame",
            "title": "Properties"
        },
        {
            "location": "/api_subpackages/biopandas.mol2/#split_multimol2",
            "text": "split_multimol2(mol2_path)  Splits a multi-mol2 file into individual Mol2 file contents.  Parameters    mol2_path  : str  Path to the multi-mol2 file. Parses gzip files if the filepath\nends on .gz.    Returns  A generator object for lists for every extracted mol2-file. Lists contain\n    the molecule ID and the mol2 file contents.\n    e.g., ['ID1234', ['@ MOLECULE\\n', '...']]. Note that bytestrings\n    are returned (for reasons of efficieny) if the Mol2 content is read\n    from a gzip (.gz) file.",
            "title": "split_multimol2"
        },
        {
            "location": "/changelog/",
            "text": "Release Notes \n\n\nThe CHANGELOG for the current development version is available at\n\nhttps://github.com/rasbt/biopandas/blob/master/docs/sources/CHANGELOG.md\n.\n\n\n0.2.0 (2017-04-02)\n\n\nDownloads\n\n\n\n\nSource code (zip)\n\n\nSource code (tar.gz)\n\n\n\n\nNew Features\n\n\n\n\nAdded an \namino3to1\n method to \nPandasPdb\n data frames to convert 3-amino acid letter codes to 1-letter codes.\n\n\nAdded a \ndistance\n method to \nPandasPdb\n data frames to compute the Euclidean distance between atoms and a reference point.\n\n\nAdded the \nPandasMol2\n class for working with Tripos MOL2 files in pandas DataFrames.\n\n\n\n\nChanges\n\n\n\n\nPandasPDB\n was renamed to \nPandasPdb\n.\n\n\nRaises a warning if \nPandasPdb\n is written to PDB and ATOM and HETAM section contains unexpected columns; these columns will now be skipped.\n\n\n\n\nBug Fixes\n\n\n\n\n-\n\n\n\n\n0.1.5 (2016-11-19)\n\n\nDownloads\n\n\n\n\nSource code (zip)\n\n\nSource code (tar.gz)\n\n\n\n\nNew Features\n\n\n\n\nAdded an \nimpute_element\n method to \nPandasPDB\n objects to infer the Element Symbol from the Atom Name column.\n\n\nAdded two new selection types for \nPandasPDB\n ATOM and HETATM coordinate sections: \n'heavy'\n and \n'carbon'\n.\n\n\n\n\nChanges\n\n\n\n\nInclude test data in the PyPI package; add install_requires for pandas.\n\n\nThe \n'hydrogen'\n atom selection in \nPandasPDB\n methods is now based on the element type instead of the atom name.\n\n\nBy default, the RMSD is now computed on all atoms unless a specific selection is defined.\n\n\n\n\nBug Fixes\n\n\n\n\n-\n\n\n\n\n0.1.4 (2015-11-24)\n\n\nDownloads\n\n\n\n\nSource code (zip)\n\n\nSource code (tar.gz)\n\n\n\n\nNew Features\n\n\n-\n\n\nChanges\n\n\n\n\nNeeded to bump the version number due to a bug in the PyPI setup.py script.\n\n\nSupport for the old pandas sorting syntax (\nDataFrame.sort\n vs \nDataFrame.sort_values\n) incl. DeprecationWarning.\n\n\n\n\nBug Fixes\n\n\n-\n\n\n0.1.3 (2015-11-23)\n\n\nNew Features\n\n\n-\n\n\nChanges\n\n\n-\n\n\nBug Fixes\n\n\n\n\nException handling in tests if PDB goes down (which just happened).\n\n\nAdded a separate ANISOU engine to handle those records correctly.\n\n\n\n\n0.1.2 (2015-11-23)\n\n\n\n\nFirst Release.",
            "title": "Changelog"
        },
        {
            "location": "/changelog/#release-notes",
            "text": "The CHANGELOG for the current development version is available at https://github.com/rasbt/biopandas/blob/master/docs/sources/CHANGELOG.md .",
            "title": "Release Notes"
        },
        {
            "location": "/changelog/#020-2017-04-02",
            "text": "",
            "title": "0.2.0 (2017-04-02)"
        },
        {
            "location": "/changelog/#downloads",
            "text": "Source code (zip)  Source code (tar.gz)",
            "title": "Downloads"
        },
        {
            "location": "/changelog/#new-features",
            "text": "Added an  amino3to1  method to  PandasPdb  data frames to convert 3-amino acid letter codes to 1-letter codes.  Added a  distance  method to  PandasPdb  data frames to compute the Euclidean distance between atoms and a reference point.  Added the  PandasMol2  class for working with Tripos MOL2 files in pandas DataFrames.",
            "title": "New Features"
        },
        {
            "location": "/changelog/#changes",
            "text": "PandasPDB  was renamed to  PandasPdb .  Raises a warning if  PandasPdb  is written to PDB and ATOM and HETAM section contains unexpected columns; these columns will now be skipped.",
            "title": "Changes"
        },
        {
            "location": "/changelog/#bug-fixes",
            "text": "-",
            "title": "Bug Fixes"
        },
        {
            "location": "/changelog/#015-2016-11-19",
            "text": "",
            "title": "0.1.5 (2016-11-19)"
        },
        {
            "location": "/changelog/#downloads_1",
            "text": "Source code (zip)  Source code (tar.gz)",
            "title": "Downloads"
        },
        {
            "location": "/changelog/#new-features_1",
            "text": "Added an  impute_element  method to  PandasPDB  objects to infer the Element Symbol from the Atom Name column.  Added two new selection types for  PandasPDB  ATOM and HETATM coordinate sections:  'heavy'  and  'carbon' .",
            "title": "New Features"
        },
        {
            "location": "/changelog/#changes_1",
            "text": "Include test data in the PyPI package; add install_requires for pandas.  The  'hydrogen'  atom selection in  PandasPDB  methods is now based on the element type instead of the atom name.  By default, the RMSD is now computed on all atoms unless a specific selection is defined.",
            "title": "Changes"
        },
        {
            "location": "/changelog/#bug-fixes_1",
            "text": "-",
            "title": "Bug Fixes"
        },
        {
            "location": "/changelog/#014-2015-11-24",
            "text": "",
            "title": "0.1.4 (2015-11-24)"
        },
        {
            "location": "/changelog/#downloads_2",
            "text": "Source code (zip)  Source code (tar.gz)",
            "title": "Downloads"
        },
        {
            "location": "/changelog/#new-features_2",
            "text": "-",
            "title": "New Features"
        },
        {
            "location": "/changelog/#changes_2",
            "text": "Needed to bump the version number due to a bug in the PyPI setup.py script.  Support for the old pandas sorting syntax ( DataFrame.sort  vs  DataFrame.sort_values ) incl. DeprecationWarning.",
            "title": "Changes"
        },
        {
            "location": "/changelog/#bug-fixes_2",
            "text": "-",
            "title": "Bug Fixes"
        },
        {
            "location": "/changelog/#013-2015-11-23",
            "text": "",
            "title": "0.1.3 (2015-11-23)"
        },
        {
            "location": "/changelog/#new-features_3",
            "text": "-",
            "title": "New Features"
        },
        {
            "location": "/changelog/#changes_3",
            "text": "-",
            "title": "Changes"
        },
        {
            "location": "/changelog/#bug-fixes_3",
            "text": "Exception handling in tests if PDB goes down (which just happened).  Added a separate ANISOU engine to handle those records correctly.",
            "title": "Bug Fixes"
        },
        {
            "location": "/changelog/#012-2015-11-23",
            "text": "First Release.",
            "title": "0.1.2 (2015-11-23)"
        },
        {
            "location": "/installation/",
            "text": "Installing BioPandas \n\n\nPyPI\n\n\nYou can install the latest stable release of \nbiopandas\n directly from Python's package index via \npip\n by executing the following code from your command line:  \n\n\npip install biopandas  \n\n\n\n\nConda-forge\n\n\nVersions of \nbiopandas\n are now also available via \nconda-forge\n; you can install it via\n\n\nconda install biopandas -c conda-forge\n\n\n\n\nor simply\n\n\nconda install biopandas\n\n\n\n\nif you have \nconda-forge\n already \nadded to your channels\n.\n\n\nLatest GitHub Source Code\n\n\n\n\nYou want to try out the latest features before they go live on PyPI? Install the \nbiopandas\n dev-version latest development version from the GitHub repository by executing\n\n\npip install git+git://github.com/rasbt/biopandas.git#egg=biopandas\n\n\n\n\n\n\nAlternatively, you download the package manually from \nPYPI\n or \nGitHub\n, unzip it, navigate into the package, and execute the command:\n\n\npython setup.py install",
            "title": "Installation"
        },
        {
            "location": "/installation/#installing-biopandas",
            "text": "",
            "title": "Installing BioPandas"
        },
        {
            "location": "/installation/#pypi",
            "text": "You can install the latest stable release of  biopandas  directly from Python's package index via  pip  by executing the following code from your command line:    pip install biopandas",
            "title": "PyPI"
        },
        {
            "location": "/installation/#conda-forge",
            "text": "Versions of  biopandas  are now also available via  conda-forge ; you can install it via  conda install biopandas -c conda-forge  or simply  conda install biopandas  if you have  conda-forge  already  added to your channels .",
            "title": "Conda-forge"
        },
        {
            "location": "/installation/#latest-github-source-code",
            "text": "You want to try out the latest features before they go live on PyPI? Install the  biopandas  dev-version latest development version from the GitHub repository by executing  pip install git+git://github.com/rasbt/biopandas.git#egg=biopandas   Alternatively, you download the package manually from  PYPI  or  GitHub , unzip it, navigate into the package, and execute the command:  python setup.py install",
            "title": "Latest GitHub Source Code"
        },
        {
            "location": "/contributing/",
            "text": "How to Contribute \n\n\nI would be very happy about any kind of contributions that help to improve and extend the functionality of biopandas.\n\n\nQuick Contributor Checklist\n\n\nThis is a quick checklist about the different steps of a typical contribution to biopandas and\nother open source projects. Consider copying this list to a local text file (or the issue tracker)\nand checking off items as you go.\n\n\n\n\n[ ]  Open a new \"issue\" on GitHub to discuss the new feature / bug fix  \n\n\n[ ]  Fork the biopandas repository from GitHub (if not already done earlier)\n\n\n[ ]  Create and checkout a new topic branch   \n\n\n[ ]  Implement new feature or apply the bug-fix  \n\n\n[ ]  Add appropriate unit test functions  \n\n\n[ ]  Run \nnosetests -sv\n and make sure that all unit tests pass  \n\n\n[ ]  Check/improve the test coverage by running \nnosetests --with-coverage\n\n\n[ ]  Add a note about the change to the \n./docs/sources/CHANGELOG.md\n file  \n\n\n[ ]  Modify documentation in the appropriate location under \nbiopandas/docs/sources/\n  \n\n\n[ ]  Push the topic branch to the server and create a pull request\n\n\n[ ]  Check the Travis-CI build passed at \nhttps://travis-ci.org/rasbt/biopandas\n\n\n[ ]  Check/improve the unit test coverage at \nhttps://coveralls.io/github/rasbt/biopandas\n\n\n[ ]  Check/improve the code health at \nhttps://landscape.io/github/rasbt/biopandas\n\n\n[ ]  Squash many small commits to a larger commit\n\n\n\n\n\n\nGetting Started - Creating a New Issue and Forking the Repository\n\n\n\n\nIf you don't have a \nGitHub\n account yet, please create one to contribute to this project.\n\n\nPlease submit a ticket for your issue to discuss the fix or new feature before too much time and effort is spent for the implementation.\n\n\n\n\n\n\n\n\nFork the \nbiopandas\n repository from the GitHub web interface.\n\n\n\n\n\n\n\n\nClone the \nbiopandas\n repository to your local machine\n\n\ngit clone https://github.com/<your_username>/biopandas.git\n\n\n\n\n\n\n\n\nSyncing an Existing Fork\n\n\nIf you already forked biopandas earlier, you can bring you \"Fork\" up to date\nwith the master branch as follows:\n\n\n1. Configuring a remote that points to the upstream repository on GitHub\n\n\nList the current configured remote repository for your fork by executing\n\n\n$ git remote -v\n\n\n\n\nIf you see something like\n\n\norigin  https://github.com/<your username>/biopandas.git (fetch)\norigin  https://github.com/<your username>/biopandas.git (push)\n\n\n\n\nyou need to specify a new remote \nupstream\n repository via\n\n\n$ git remote add upstream https://github.com/rasbt/biopandas.git\n\n\n\n\nNow, verify the new upstream repository you've specified for your fork by executing\n\n\n$ git remote -v\n\n\n\n\nYou should see following output if everything is configured correctly:\n\n\norigin  https://github.com/<your username>/biopandas.git (fetch)\norigin  https://github.com/<your username>/biopandas.git (push)\nupstream    https://github.com/rasbt/biopandas.git (fetch)\nupstream    https://github.com/rasbt/biopandas.git (push)\n\n\n\n\n2. Syncing your Fork\n\n\nFirst, fetch the updates of the original project's master branch by executing:\n\n\n$ git fetch upstream\n\n\n\n\nYou should see the following output\n\n\nremote: Counting objects: xx, done.\nremote: Compressing objects: 100% (xx/xx), done.\nremote: Total xx (delta xx), reused xx (delta x)\nUnpacking objects: 100% (xx/xx), done.\nFrom https://github.com/rasbt/biopandas\n * [new branch]      master     -> upstream/master\n\n\n\n\nThis means that the commits to the \nrasbt/biopandas\n master branch are now\nstored in the local branch \nupstream/master\n.\n\n\nIf you are not already on your local project's master branch, execute\n\n\n$ git checkout master\n\n\n\n\nFinally, merge the changes in upstream/master to your local master branch by\nexecuting\n\n\n$ git merge upstream/master\n\n\n\n\nwhich will give you an output that looks similar to\n\n\nUpdating xxx...xxx\nFast-forward\nSOME FILE1                    |    12 +++++++\nSOME FILE2                    |    10 +++++++\n2 files changed, 22 insertions(+),\n\n\n\n\nMaking Changes in a New Topic Branch\n\n\n1. Creating a new feature branch\n\n\nPlease avoid working directly on the master branch but create a new feature branch:\n\n\n$ git branch <new_feature>\n\n\n\n\nSwitch to the new feature branch by executing\n\n\n$ git checkout <new_feature>\n\n\n\n\n2. Developing the new feature / bug fix\n\n\n3. Testing your code\n\n\nAdding/modifying the unit tests and check if they pass:\n\n\n$ nosetests -sv\n\n\n\n\n$ nosetests --with-coverage\n\n\n\n\n4. Documenting the changes\n\n\nPlease add an entry to the \nbiopandas/docs/sources/CHANGELOG.md\n file.\nIf it is a new feature, it would also be nice if you could update the documentation in appropriate location in \nbiopandas/sources\n.\n\n\n5. Committing the changes\n\n\nWhen you are ready to commit the changes, please provide a meaningful \ncommit\n message:\n\n\n$ git add <modifies_files> # or `git add .`\n$ git commit -m '<meaningful commit message>'\n\n\n\n\n6. Optional: squashing commits\n\n\nIf you made multiple smaller commits, it would be nice if you could group them into a larger, summarizing commit. First, list your recent commit via\n\n\n$ git log\n\n\n\n\nwhich will list the commits from newest to oldest in the following format by default:\n\n\ncommit 046e3af8a9127df8eac879454f029937c8a31c41\nAuthor: rasbt <mail@sebastianraschka.com>\nDate:   Tue Nov 24 03:46:37 2015 -0500\n\n    fixed setup.py\n\ncommit c3c00f6ba0e8f48bbe1c9081b8ae3817e57ecc5c\nAuthor: rasbt <mail@sebastianraschka.com>\nDate:   Tue Nov 24 03:04:39 2015 -0500\n\n        documented feature x\n\ncommit d87934fe8726c46f0b166d6290a3bf38915d6e75\nAuthor: rasbt <mail@sebastianraschka.com>\nDate:   Tue Nov 24 02:44:45 2015 -0500\n\n        added support for feature x\n\n\n\n\nAssuming that it would make sense to group these 3 commits into one, we can execute\n\n\n$ git rebase -i HEAD~3\n\n\n\n\nwhich will bring our default git editor with the following contents:\n\n\npick d87934f added support for feature x\npick c3c00f6 documented feature x\npick 046e3af fixed setup.py\n\n\n\n\nSince \nc3c00f6\n and \n046e3af\n are related to the original commit of \nfeature x\n, let's keep the \nd87934f\n and squash the 2 following commits into this initial one by changes the lines to\n\n\npick d87934f added support for feature x\nsquash c3c00f6 documented feature x\nsquash 046e3af fixed setup.py\n\n\n\n\nNow, save the changes in your editor. Now, quitting the editor will apply the \nrebase\n changes, and the editor will open a second time, prompting you to enter a new commit message. In this case, we could enter \nsupport for feature x\n to summarize the contributions.\n\n\n7. Uploading the changes\n\n\nPush your changes to a topic branch to the git server by executing:\n\n\n$ git push origin <feature_branch>\n\n\n\n\n8. Submitting a \npull request\n\n\nGo to your GitHub repository online, select the new feature branch, and submit a new pull request:\n\n\n\n\nNotes for the Developers\n\n\nBuilding the documentation\n\n\nThe documentation is built via \nMkDocs\n; to ensure that the documentation is rendered correctly, you can view the documentation locally by executing \nmkdocs serve\n from the \nbiopandas/docs\n directory.\n\n\nFor example,\n\n\n~/github/biopandas/docs$ mkdocs serve\n\n\n\n\n1.  Editing the Tutorials\n\n\nPlease note that documents containing code examples are generated from IPython Notebook files and converted to markdown via\n\n\n~/github/biopandas/docs/examples$ nbconvert --to markdown <file.ipynb>\n\n\n\n\nThe markdown file should be placed into the documentation directory at \nbiopandas/docs/sources\n to build the documentation via  MkDocs.\nIf you are adding a new document, please also include it in the pages section in the \nbiopandas/docs/mkdocs.yml\n file.\n\n\n2. Building the API documentation\n\n\nTo build the API documentation, navigate to \nbiopandas/docs\n and execute the \nmake_api.py\n file from this directory via\n\n\n~/github/biopandas/docs$ python make_api.py\n\n\n\n\nThis should place the API documentation into the correct directories in \nbiopandas/docs/sources/api\n.\n\n\n3. Building static HTML files of the documentation\n\n\nBuild the static HTML files of the biopandas documentation via\n\n\n~/github/biopandas/docs$ mkdocs build --clean\n\n\n\n\nTo deploy the documentation, execute\n\n\n~/github/biopandas/docs$ mkdocs gh-deploy --clean\n\n\n\n\nUploading a new version to PyPI\n\n\n1. Creating a new testing environment\n\n\nAssuming we are using \nconda\n, create a new python environment via\n\n\n$ conda create -n 'biopandas-testing' python=3 pandas\n\n\n\n\nNext, activate the environment by executing\n\n\n$ source activate biopandas-testing\n\n\n\n\n2. Installing the package from local files\n\n\nTest the installation by executing\n\n\n$ python setup.py install --record files.txt\n\n\n\n\nthe \n--record files.txt\n flag will create a \nfiles.txt\n file listing the locations where these files will be installed.\n\n\nTry to import the package to see if it works, for example, by executing\n\n\n$ python -c 'import biopandas; print(biopandas.__file__)'\n\n\n\n\nIf everything seems to be fine, remove the installation via\n\n\n$ cat files.txt | xargs rm -rf ; rm files.txt\n\n\n\n\nNext, test if \npip\n is able to install the packages. First, navigate to a different directory, and from there, install the package:\n\n\n$ pip install code/biopandas/\n\n\n\n\nand uninstall it again\n\n\n$ pip uninstall biopandas\n\n\n\n\n3. Deploying the package\n\n\nConsider deploying the package to the PyPI test server first. The setup instructions can be found \nhere\n.\n\n\n$ python setup.py sdist upload -r https://testpypi.python.org/pypi\n\n\n\n\nTest if it can be installed from there by executing\n\n\n$ pip install -i https://testpypi.python.org/pypi biopandas\n\n\n\n\nand uninstall it\n\n\n$ pip uninstall biopandas\n\n\n\n\nAfter this dry-run succeeded, repeat this process using the \"real\" PyPI:\n\n\n$ python setup.py sdist upload\n\n\n\n\n4. Removing the virtual environment\n\n\nFinally, to cleanup our local drive, remove the virtual testing environment via\n\n\n$ conda remove --name 'biopandas-testing' --all",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#how-to-contribute",
            "text": "I would be very happy about any kind of contributions that help to improve and extend the functionality of biopandas.",
            "title": "How to Contribute"
        },
        {
            "location": "/contributing/#quick-contributor-checklist",
            "text": "This is a quick checklist about the different steps of a typical contribution to biopandas and\nother open source projects. Consider copying this list to a local text file (or the issue tracker)\nand checking off items as you go.   [ ]  Open a new \"issue\" on GitHub to discuss the new feature / bug fix    [ ]  Fork the biopandas repository from GitHub (if not already done earlier)  [ ]  Create and checkout a new topic branch     [ ]  Implement new feature or apply the bug-fix    [ ]  Add appropriate unit test functions    [ ]  Run  nosetests -sv  and make sure that all unit tests pass    [ ]  Check/improve the test coverage by running  nosetests --with-coverage  [ ]  Add a note about the change to the  ./docs/sources/CHANGELOG.md  file    [ ]  Modify documentation in the appropriate location under  biopandas/docs/sources/     [ ]  Push the topic branch to the server and create a pull request  [ ]  Check the Travis-CI build passed at  https://travis-ci.org/rasbt/biopandas  [ ]  Check/improve the unit test coverage at  https://coveralls.io/github/rasbt/biopandas  [ ]  Check/improve the code health at  https://landscape.io/github/rasbt/biopandas  [ ]  Squash many small commits to a larger commit",
            "title": "Quick Contributor Checklist"
        },
        {
            "location": "/contributing/#getting-started-creating-a-new-issue-and-forking-the-repository",
            "text": "If you don't have a  GitHub  account yet, please create one to contribute to this project.  Please submit a ticket for your issue to discuss the fix or new feature before too much time and effort is spent for the implementation.     Fork the  biopandas  repository from the GitHub web interface.     Clone the  biopandas  repository to your local machine  git clone https://github.com/<your_username>/biopandas.git",
            "title": "Getting Started - Creating a New Issue and Forking the Repository"
        },
        {
            "location": "/contributing/#syncing-an-existing-fork",
            "text": "If you already forked biopandas earlier, you can bring you \"Fork\" up to date\nwith the master branch as follows:",
            "title": "Syncing an Existing Fork"
        },
        {
            "location": "/contributing/#1-configuring-a-remote-that-points-to-the-upstream-repository-on-github",
            "text": "List the current configured remote repository for your fork by executing  $ git remote -v  If you see something like  origin  https://github.com/<your username>/biopandas.git (fetch)\norigin  https://github.com/<your username>/biopandas.git (push)  you need to specify a new remote  upstream  repository via  $ git remote add upstream https://github.com/rasbt/biopandas.git  Now, verify the new upstream repository you've specified for your fork by executing  $ git remote -v  You should see following output if everything is configured correctly:  origin  https://github.com/<your username>/biopandas.git (fetch)\norigin  https://github.com/<your username>/biopandas.git (push)\nupstream    https://github.com/rasbt/biopandas.git (fetch)\nupstream    https://github.com/rasbt/biopandas.git (push)",
            "title": "1. Configuring a remote that points to the upstream repository on GitHub"
        },
        {
            "location": "/contributing/#2-syncing-your-fork",
            "text": "First, fetch the updates of the original project's master branch by executing:  $ git fetch upstream  You should see the following output  remote: Counting objects: xx, done.\nremote: Compressing objects: 100% (xx/xx), done.\nremote: Total xx (delta xx), reused xx (delta x)\nUnpacking objects: 100% (xx/xx), done.\nFrom https://github.com/rasbt/biopandas\n * [new branch]      master     -> upstream/master  This means that the commits to the  rasbt/biopandas  master branch are now\nstored in the local branch  upstream/master .  If you are not already on your local project's master branch, execute  $ git checkout master  Finally, merge the changes in upstream/master to your local master branch by\nexecuting  $ git merge upstream/master  which will give you an output that looks similar to  Updating xxx...xxx\nFast-forward\nSOME FILE1                    |    12 +++++++\nSOME FILE2                    |    10 +++++++\n2 files changed, 22 insertions(+),",
            "title": "2. Syncing your Fork"
        },
        {
            "location": "/contributing/#making-changes-in-a-new-topic-branch",
            "text": "",
            "title": "Making Changes in a New Topic Branch"
        },
        {
            "location": "/contributing/#1-creating-a-new-feature-branch",
            "text": "Please avoid working directly on the master branch but create a new feature branch:  $ git branch <new_feature>  Switch to the new feature branch by executing  $ git checkout <new_feature>",
            "title": "1. Creating a new feature branch"
        },
        {
            "location": "/contributing/#2-developing-the-new-feature-bug-fix",
            "text": "",
            "title": "2. Developing the new feature / bug fix"
        },
        {
            "location": "/contributing/#3-testing-your-code",
            "text": "Adding/modifying the unit tests and check if they pass:  $ nosetests -sv  $ nosetests --with-coverage",
            "title": "3. Testing your code"
        },
        {
            "location": "/contributing/#4-documenting-the-changes",
            "text": "Please add an entry to the  biopandas/docs/sources/CHANGELOG.md  file.\nIf it is a new feature, it would also be nice if you could update the documentation in appropriate location in  biopandas/sources .",
            "title": "4. Documenting the changes"
        },
        {
            "location": "/contributing/#5-committing-the-changes",
            "text": "When you are ready to commit the changes, please provide a meaningful  commit  message:  $ git add <modifies_files> # or `git add .`\n$ git commit -m '<meaningful commit message>'",
            "title": "5. Committing the changes"
        },
        {
            "location": "/contributing/#6-optional-squashing-commits",
            "text": "If you made multiple smaller commits, it would be nice if you could group them into a larger, summarizing commit. First, list your recent commit via  $ git log  which will list the commits from newest to oldest in the following format by default:  commit 046e3af8a9127df8eac879454f029937c8a31c41\nAuthor: rasbt <mail@sebastianraschka.com>\nDate:   Tue Nov 24 03:46:37 2015 -0500\n\n    fixed setup.py\n\ncommit c3c00f6ba0e8f48bbe1c9081b8ae3817e57ecc5c\nAuthor: rasbt <mail@sebastianraschka.com>\nDate:   Tue Nov 24 03:04:39 2015 -0500\n\n        documented feature x\n\ncommit d87934fe8726c46f0b166d6290a3bf38915d6e75\nAuthor: rasbt <mail@sebastianraschka.com>\nDate:   Tue Nov 24 02:44:45 2015 -0500\n\n        added support for feature x  Assuming that it would make sense to group these 3 commits into one, we can execute  $ git rebase -i HEAD~3  which will bring our default git editor with the following contents:  pick d87934f added support for feature x\npick c3c00f6 documented feature x\npick 046e3af fixed setup.py  Since  c3c00f6  and  046e3af  are related to the original commit of  feature x , let's keep the  d87934f  and squash the 2 following commits into this initial one by changes the lines to  pick d87934f added support for feature x\nsquash c3c00f6 documented feature x\nsquash 046e3af fixed setup.py  Now, save the changes in your editor. Now, quitting the editor will apply the  rebase  changes, and the editor will open a second time, prompting you to enter a new commit message. In this case, we could enter  support for feature x  to summarize the contributions.",
            "title": "6. Optional: squashing commits"
        },
        {
            "location": "/contributing/#7-uploading-the-changes",
            "text": "Push your changes to a topic branch to the git server by executing:  $ git push origin <feature_branch>",
            "title": "7. Uploading the changes"
        },
        {
            "location": "/contributing/#8-submitting-a-pull-request",
            "text": "Go to your GitHub repository online, select the new feature branch, and submit a new pull request:",
            "title": "8. Submitting a pull request"
        },
        {
            "location": "/contributing/#notes-for-the-developers",
            "text": "",
            "title": "Notes for the Developers"
        },
        {
            "location": "/contributing/#building-the-documentation",
            "text": "The documentation is built via  MkDocs ; to ensure that the documentation is rendered correctly, you can view the documentation locally by executing  mkdocs serve  from the  biopandas/docs  directory.  For example,  ~/github/biopandas/docs$ mkdocs serve",
            "title": "Building the documentation"
        },
        {
            "location": "/contributing/#1-editing-the-tutorials",
            "text": "Please note that documents containing code examples are generated from IPython Notebook files and converted to markdown via  ~/github/biopandas/docs/examples$ nbconvert --to markdown <file.ipynb>  The markdown file should be placed into the documentation directory at  biopandas/docs/sources  to build the documentation via  MkDocs.\nIf you are adding a new document, please also include it in the pages section in the  biopandas/docs/mkdocs.yml  file.",
            "title": "1.  Editing the Tutorials"
        },
        {
            "location": "/contributing/#2-building-the-api-documentation",
            "text": "To build the API documentation, navigate to  biopandas/docs  and execute the  make_api.py  file from this directory via  ~/github/biopandas/docs$ python make_api.py  This should place the API documentation into the correct directories in  biopandas/docs/sources/api .",
            "title": "2. Building the API documentation"
        },
        {
            "location": "/contributing/#3-building-static-html-files-of-the-documentation",
            "text": "Build the static HTML files of the biopandas documentation via  ~/github/biopandas/docs$ mkdocs build --clean  To deploy the documentation, execute  ~/github/biopandas/docs$ mkdocs gh-deploy --clean",
            "title": "3. Building static HTML files of the documentation"
        },
        {
            "location": "/contributing/#uploading-a-new-version-to-pypi",
            "text": "",
            "title": "Uploading a new version to PyPI"
        },
        {
            "location": "/contributing/#1-creating-a-new-testing-environment",
            "text": "Assuming we are using  conda , create a new python environment via  $ conda create -n 'biopandas-testing' python=3 pandas  Next, activate the environment by executing  $ source activate biopandas-testing",
            "title": "1. Creating a new testing environment"
        },
        {
            "location": "/contributing/#2-installing-the-package-from-local-files",
            "text": "Test the installation by executing  $ python setup.py install --record files.txt  the  --record files.txt  flag will create a  files.txt  file listing the locations where these files will be installed.  Try to import the package to see if it works, for example, by executing  $ python -c 'import biopandas; print(biopandas.__file__)'  If everything seems to be fine, remove the installation via  $ cat files.txt | xargs rm -rf ; rm files.txt  Next, test if  pip  is able to install the packages. First, navigate to a different directory, and from there, install the package:  $ pip install code/biopandas/  and uninstall it again  $ pip uninstall biopandas",
            "title": "2. Installing the package from local files"
        },
        {
            "location": "/contributing/#3-deploying-the-package",
            "text": "Consider deploying the package to the PyPI test server first. The setup instructions can be found  here .  $ python setup.py sdist upload -r https://testpypi.python.org/pypi  Test if it can be installed from there by executing  $ pip install -i https://testpypi.python.org/pypi biopandas  and uninstall it  $ pip uninstall biopandas  After this dry-run succeeded, repeat this process using the \"real\" PyPI:  $ python setup.py sdist upload",
            "title": "3. Deploying the package"
        },
        {
            "location": "/contributing/#4-removing-the-virtual-environment",
            "text": "Finally, to cleanup our local drive, remove the virtual testing environment via  $ conda remove --name 'biopandas-testing' --all",
            "title": "4. Removing the virtual environment"
        },
        {
            "location": "/citing/",
            "text": "Citing\n\n\nIf you use BioPandas as part of your workflow in a scientific publication, please consider citing the BioPandas repository with the following DOI:\n\n\nSebastian Raschka. (2017). rasbt/biopandas: v0.2.0 (2017-04-02). Zenodo. \nhttp://doi.org/10.5281/zenodo.439736\n\n\n@misc{raschkas_2016_49235,\n  author       = {Raschka, Sebastian},\n  title        = {BioPandas},\n  month        = apr,\n  year         = 2017,\n  doi          = {10.5281/zenodo.439736},\n  url          = {http://doi.org/10.5281/zenodo.439736}\n}",
            "title": "Citing"
        },
        {
            "location": "/citing/#citing",
            "text": "If you use BioPandas as part of your workflow in a scientific publication, please consider citing the BioPandas repository with the following DOI:  Sebastian Raschka. (2017). rasbt/biopandas: v0.2.0 (2017-04-02). Zenodo.  http://doi.org/10.5281/zenodo.439736  @misc{raschkas_2016_49235,\n  author       = {Raschka, Sebastian},\n  title        = {BioPandas},\n  month        = apr,\n  year         = 2017,\n  doi          = {10.5281/zenodo.439736},\n  url          = {http://doi.org/10.5281/zenodo.439736}\n}",
            "title": "Citing"
        }
    ]
}